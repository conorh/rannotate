

--- !ruby/object:RaComment 
attributes: 
  id: 192
  comment: ''
new_record: true
--- !ruby/object:RaFile
attributes:
  id: 3
  ra_comment_id: 192
  ra_library_id: 0
  name: testdoc-0.0.1/base.rb
  type: RaFile
  full_name: testdoc-0.0.1/base.rb
  parent_id: 0
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 193
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 9
  ra_comment_id: 193
  ra_library_id: 0  
  superclass: StandardError
  name: ReadOnlyRecord
  type: RaClass
  full_name: ActiveRecord::ReadOnlyRecord
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 194
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 11
  ra_comment_id: 194
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: StatementInvalid
  type: RaClass
  full_name: ActiveRecord::StatementInvalid
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 195
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 13
  ra_comment_id: 195
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: AdapterNotSpecified
  type: RaClass
  full_name: ActiveRecord::AdapterNotSpecified
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 196
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 15
  ra_comment_id: 196
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: AttributeAssignmentError
  type: RaClass
  full_name: ActiveRecord::AttributeAssignmentError
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 197
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 17
  ra_comment_id: 197
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: AssociationTypeMismatch
  type: RaClass
  full_name: ActiveRecord::AssociationTypeMismatch
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 198
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 19
  ra_comment_id: 198
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: RecordNotFound
  type: RaClass
  full_name: ActiveRecord::RecordNotFound
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 199
  comment: >2
    # Active Record objects don't specify their attributes directly, but rather
    infer them from the table definition with

    # which they're linked. Adding, removing, and changing attributes and their type
    is done directly in the database. Any change

    # is instantly reflected in the Active Record objects. The mapping that binds a
    given Active Record class to a certain

    # database table will happen automatically in most common cases, but can be
    overwritten for the uncommon ones.

    #

    # See the mapping rules in table_name and the full example in
    link:files/README.html for more insight.

    #

    # == Creation

    #

    # Active Records accept constructor parameters either in a hash or as a block.
    The hash method is especially useful when

    # you're receiving the data from somewhere else, like a HTTP request. It works
    like this:

    #

    #   user = User.new(:name => "David", :occupation => "Code Artist")

    #   user.name # => "David"

    #

    # You can also use block initialization:

    #

    #   user = User.new do |u|

    #     u.name = "David"

    #     u.occupation = "Code Artist"

    #   end

    #

    # And of course you can just create a bare object and specify the attributes
    after the fact:

    #

    #   user = User.new

    #   user.name = "David"

    #   user.occupation = "Code Artist"

    #

    # == Conditions

    #

    # Conditions can either be specified as a string or an array representing the
    WHERE-part of an SQL statement.

    # The array form is to be used when the condition input is tainted and requires
    sanitization. The string form can

    # be used for statements that don't involve tainted data. Examples:

    #

    #   User < ActiveRecord::Base

    #     def self.authenticate_unsafely(user_name, password)

    #       find(:first, :conditions => "user_name = '#{user_name}' AND password =
    '#{password}'")

    #     end

    #

    #     def self.authenticate_safely(user_name, password)

    #       find(:first, :conditions => [ "user_name = ? AND password = ?",
    user_name, password ])

    #     end

    #   end

    #

    # The <tt>authenticate_unsafely</tt> method inserts the parameters directly into
    the query and is thus susceptible to SQL-injection

    # attacks if the <tt>user_name</tt> and +password+ parameters come directly from
    a HTTP request. The <tt>authenticate_safely</tt> method,

    # on the other hand, will sanitize the <tt>user_name</tt> and +password+ before
    inserting them in the query, which will ensure that

    # an attacker can't escape the query and fake the login (or worse).

    #

    # When using multiple parameters in the conditions, it can easily become hard to
    read exactly what the fourth or fifth

    # question mark is supposed to represent. In those cases, you can resort to
    named bind variables instead. That's done by replacing

    # the question marks with symbols and supplying a hash with values for the
    matching symbol keys:

    #

    #   Company.find(:first, [

    #     "id = :id AND name = :name AND division = :division AND created_at >
    :accounting_date",

    #     { :id => 3, :name => "37signals", :division => "First", :accounting_date
    => '2005-01-01' }

    #   ])

    #

    # == Overwriting default accessors

    #

    # All column values are automatically available through basic accessors on the
    Active Record object, but some times you

    # want to specialize this behavior. This can be done by either by overwriting
    the default accessors (using the same

    # name as the attribute) calling read_attribute(attr_name) and
    write_attribute(attr_name, value) to actually change things.

    # Example:

    #

    #   class Song < ActiveRecord::Base

    #     # Uses an integer of seconds to hold the length of the song

    #

    #     def length=(minutes)

    #       write_attribute(:length, minutes * 60)

    #     end

    #

    #     def length

    #       read_attribute(:length) / 60

    #     end

    #   end

    #

    # You can alternatively use self[:attribute]=(value) and self[:attribute]
    instead of write_attribute(:attribute, vaule) and

    # read_attribute(:attribute) as a shorter form.

    #

    # == Accessing attributes before they have been typecasted

    #

    # Sometimes you want to be able to read the raw attribute data without having
    the column-determined typecast run its course first.

    # That can be done by using the <attribute>_before_type_cast accessors that all
    attributes have. For example, if your Account model

    # has a balance attribute, you can call account.balance_before_type_cast or
    account.id_before_type_cast.

    #

    # This is especially useful in validation situations where the user might supply
    a string for an integer field and you want to display

    # the original string back in an error message. Accessing the attribute normally
    would typecast the string to 0, which isn't what you

    # want.

    #

    # == Dynamic attribute-based finders

    #

    # Dynamic attribute-based finders are a cleaner way of getting (and/or creating)
    objects by simple queries without turning to SQL. They work by

    # appending the name of an attribute to <tt>find_by_</tt> or
    <tt>find_all_by_</tt>, so you get finders like Person.find_by_user_name,

    # Person.find_all_by_last_name, Payment.find_by_transaction_id. So instead of
    writing

    # <tt>Person.find(:first, ["user_name = ?", user_name])</tt>, you just do
    <tt>Person.find_by_user_name(user_name)</tt>.

    # And instead of writing <tt>Person.find(:all, ["last_name = ?",
    last_name])</tt>, you just do <tt>Person.find_all_by_last_name(last_name)</tt>.

    #

    # It's also possible to use multiple attributes in the same find by separating
    them with "_and_", so you get finders like

    # <tt>Person.find_by_user_name_and_password</tt> or even
    <tt>Payment.find_by_purchaser_and_state_and_country</tt>. So instead of writing

    # <tt>Person.find(:first, ["user_name = ? AND password = ?", user_name,
    password])</tt>, you just do

    # <tt>Person.find_by_user_name_and_password(user_name, password)</tt>.

    #

    # It's even possible to use all the additional parameters to find. For example,
    the full interface for Payment.find_all_by_amount

    # is actually Payment.find_all_by_amount(amount, options). And the full
    interface to Person.find_by_user_name is

    # actually Person.find_by_user_name(user_name, options). So you could call
    <tt>Payment.find_all_by_amount(50, :order => "created_on")</tt>.

    #

    # The same dynamic finder style can be used to create the object if it doesn't
    already exist. This dynamic finder is called with

    # <tt>find_or_create_by_</tt> and will return the object if it already exists
    and otherwise creates it, then returns it. Example:

    #

    #   # No 'Summer' tag exists

    #   Tag.find_or_create_by_name("Summer") # equal to Tag.create(:name =>
    "Summer")

    #   

    #   # Now the 'Summer' tag does exist

    #   Tag.find_or_create_by_name("Summer") # equal to Tag.find_by_name("Summer")

    #

    # == Saving arrays, hashes, and other non-mappable objects in text columns

    #

    # Active Record can serialize any object in text columns using YAML. To do so,
    you must specify this with a call to the class method +serialize+.

    # This makes it possible to store arrays, hashes, and other non-mappable objects
    without doing any additional work. Example:

    #

    #   class User < ActiveRecord::Base

    #     serialize :preferences

    #   end

    #

    #   user = User.create(:preferences) => { "background" => "black", "display" =>
    large })

    #   User.find(user.id).preferences # => { "background" => "black", "display" =>
    large }

    #

    # You can also specify a class option as the second parameter that'll raise an
    exception if a serialized object is retrieved as a

    # descendent of a class not in the hierarchy. Example:

    #

    #   class User < ActiveRecord::Base

    #     serialize :preferences, Hash

    #   end

    #

    #   user = User.create(:preferences => %w( one two three ))

    #   User.find(user.id).preferences    # raises SerializationTypeMismatch

    #

    # == Single table inheritance

    #

    # Active Record allows inheritance by storing the name of the class in a column
    that by default is called "type" (can be changed

    # by overwriting <tt>Base.inheritance_column</tt>). This means that an
    inheritance looking like this:

    #

    #   class Company < ActiveRecord::Base; end

    #   class Firm < Company; end

    #   class Client < Company; end

    #   class PriorityClient < Client; end

    #

    # When you do Firm.create(:name => "37signals"), this record will be saved in
    the companies table with type = "Firm". You can then

    # fetch this row again using Company.find(:first, "name = '37signals'") and it
    will return a Firm object.

    #

    # If you don't have a type column defined in your table, single-table
    inheritance won't be triggered. In that case, it'll work just

    # like normal subclasses with no special magic for differentiating between them
    or reloading the right type with find.

    #

    # Note, all the attributes for all the cases are kept in the same table. Read
    more:

    # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html

    #

    # == Connection to multiple databases in different models

    #

    # Connections are usually created through
    ActiveRecord::Base.establish_connection and retrieved by
    ActiveRecord::Base.connection.

    # All classes inheriting from ActiveRecord::Base will use this connection. But
    you can also set a class-specific connection.

    # For example, if Course is a ActiveRecord::Base, but resides in a different
    database you can just say Course.establish_connection

    # and Course *and all its subclasses* will use this connection instead.

    #

    # This feature is implemented by keeping a connection pool in ActiveRecord::Base
    that is a Hash indexed by the class. If a connection is

    # requested, the retrieve_connection method will go up the class-hierarchy until
    a connection is found in the connection pool.

    #

    # == Exceptions

    #

    # * +ActiveRecordError+ -- generic error class and superclass of all other
    errors raised by Active Record

    # * +AdapterNotSpecified+ -- the configuration hash used in
    <tt>establish_connection</tt> didn't include a

    #   <tt>:adapter</tt> key.

    # * +AdapterNotFound+ -- the <tt>:adapter</tt> key used in
    <tt>establish_connection</tt> specified an non-existent adapter

    #   (or a bad spelling of an existing one).

    # * +AssociationTypeMismatch+ -- the object assigned to the association wasn't
    of the type specified in the association definition.

    # * +SerializationTypeMismatch+ -- the object serialized wasn't of the class
    specified as the second parameter.

    # * +ConnectionNotEstablished+ -- no connection has been established. Use
    <tt>establish_connection</tt> before querying.

    # * +RecordNotFound+ -- no record responded to the find* method.

    #   Either the row with the given ID doesn't exist or the row didn't meet the
    additional restrictions.

    # * +StatementInvalid+ -- the database server rejected the SQL statement. The
    precise error is added in the  message.

    #   Either the record with the given ID doesn't exist or the record didn't meet
    the additional restrictions.

    # * +MultiparameterAssignmentErrors+ -- collection of errors that occurred
    during a mass assignment using the

    #   +attributes=+ method. The +errors+ property of this exception contains an
    array of +AttributeAssignmentError+

    #   objects that should be inspected to determine which attributes triggered the
    errors.

    # * +AttributeAssignmentError+ -- an error occurred while doing a mass
    assignment through the +attributes=+ method.

    #   You can inspect the +attribute+ property of the exception object to
    determine which attribute triggered the error.

    #

    # *Note*: The attributes listed are class-level attributes (accessible from both
    the class and instance level).

    # So it's possible to assign a logger to the class through Base.logger= which
    will then be used by all

    # instances in the current object space.

new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 21
  ra_comment_id: 199
  ra_library_id: 0  
  superclass: Object
  name: Base
  type: RaClass
  full_name: ActiveRecord::Base
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 200
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 172
  ra_comment_id: 200
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: SerializationTypeMismatch
  type: RaClass
  full_name: ActiveRecord::SerializationTypeMismatch
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 201
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 174
  ra_comment_id: 201
  ra_library_id: 0  
  superclass: StandardError
  name: ActiveRecordError
  type: RaClass
  full_name: ActiveRecord::ActiveRecordError
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 202
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 176
  ra_comment_id: 202
  ra_library_id: 0  
  superclass: StandardError
  name: ConfigurationError
  type: RaClass
  full_name: ActiveRecord::ConfigurationError
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 203
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 178
  ra_comment_id: 203
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: ConnectionNotEstablished
  type: RaClass
  full_name: ActiveRecord::ConnectionNotEstablished
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 204
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 180
  ra_comment_id: 204
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: SubclassNotFound
  type: RaClass
  full_name: ActiveRecord::SubclassNotFound
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 205
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 182
  ra_comment_id: 205
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: MultiparameterAssignmentErrors
  type: RaClass
  full_name: ActiveRecord::MultiparameterAssignmentErrors
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 206
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 184
  ra_comment_id: 206
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: AdapterNotFound
  type: RaClass
  full_name: ActiveRecord::AdapterNotFound
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 207
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 186
  ra_comment_id: 207
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: StaleObjectError
  type: RaClass
  full_name: ActiveRecord::StaleObjectError
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 208
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 188
  ra_comment_id: 208
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: PreparedStatementInvalid
  type: RaClass
  full_name: ActiveRecord::PreparedStatementInvalid
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 209
  comment: ''
new_record: true
--- !ruby/object:RaClass
attributes: 
  id: 190
  ra_comment_id: 209
  ra_library_id: 0  
  superclass: ActiveRecordError
  name: ConnectionFailed
  type: RaClass
  full_name: ActiveRecord::ConnectionFailed
  parent_id: 7
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 210
  comment: ''
new_record: true
--- !ruby/object:RaModule
attributes: 
  id: 7
  ra_comment_id: 210
  ra_library_id: 0  
  superclass: 
  name: ActiveRecord
  type: RaModule
  full_name: ActiveRecord
  parent_id: 3
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 8
  ra_container_id: 7
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 10
  ra_container_id: 9
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 12
  ra_container_id: 11
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 14
  ra_container_id: 13
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 16
  ra_container_id: 15
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 18
  ra_container_id: 17
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 20
  ra_container_id: 19
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 171
  ra_container_id: 21
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 173
  ra_container_id: 172
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 175
  ra_container_id: 174
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 177
  ra_container_id: 176
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 179
  ra_container_id: 178
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 181
  ra_container_id: 180
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 183
  ra_container_id: 182
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 185
  ra_container_id: 184
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 187
  ra_container_id: 186
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 189
  ra_container_id: 188
  file_name: testdoc-0.0.1/base.rb
new_record: true
--- !ruby/object:RaInFile 
attributes: 
  id: 191
  ra_container_id: 190
  file_name: testdoc-0.0.1/base.rb
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 212
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 263
        def self.reset_subclasses
          nonreloadables = []
          subclasses.each do |klass|
            unless klass.reloadable?
              nonreloadables << klass
              next
            end
            klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }
            klass.instance_methods(false).each { |m| klass.send :undef_method, m }
          end
          @@subclasses = {}
          nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) << klass }
        end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 211
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 22
  ra_comment_id: 211
  visibility: 1
  name: reset_subclasses
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 212
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 214
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 381
          def find(*args)
            options = extract_options_from_args!(args)

            # Inherit :readonly from finder scope if set.  Otherwise,
            # if :joins is not blank then :readonly defaults to true.
            unless options.has_key?(:readonly)
              if scoped?(:find, :readonly)
                options[:readonly] = scope(:find, :readonly)
              elsif !options[:joins].blank?
                options[:readonly] = true
              end
            end

            case args.first
              when :first
                find(:all, options.merge(options[:include] ? { } : { :limit => 1 })).first
              when :all
                records = options[:include] ? find_with_associations(options) : find_by_sql(construct_finder_sql(options))
                records.each { |record| record.readonly! } if options[:readonly]
                records
              else
                return args.first if args.first.kind_of?(Array) && args.first.empty?
                expects_array = args.first.kind_of?(Array)
                
                conditions = " AND (#{sanitize_sql(options[:conditions])})" if options[:conditions]

                ids = args.flatten.compact.uniq
                case ids.size
                  when 0
                    raise RecordNotFound, "Couldn't find #{name} without an ID#{conditions}"
                  when 1
                    if result = find(:first, options.merge({ :conditions => "#{table_name}.#{primary_key} = #{sanitize(ids.first)}#{conditions}" }))
                      return expects_array ? [ result ] : result
                    else
                      raise RecordNotFound, "Couldn't find #{name} with ID=#{ids.first}#{conditions}"
                    end
                  else
                    # Find multiple ids
                    ids_list = ids.map { |id| sanitize(id) }.join(',')
                    result   = find(:all, options.merge({ :conditions => "#{table_name}.#{primary_key} IN (#{ids_list})#{conditions}"}))
                    if result.size == ids.size
                      return result
                    else
                      raise RecordNotFound, "Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions}"
                    end
                end
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 213
  comment: >2
    # Find operates with three different retrieval approaches:

    #

    # * Find by id: This can either be a specific id (1), a list of ids (1, 5, 6),
    or an array of ids ([5, 6, 10]).

    #   If no record can be found for all of the listed ids, then RecordNotFound
    will be raised.

    # * Find first: This will return the first record matched by the options used.
    These options can either be specific

    #   conditions or merely an order. If no record can matched, nil is returned.

    # * Find all: This will return all the records matched by the options used. If
    no records are found, an empty array is returned.

    #

    # All approaches accept an option hash as their last parameter. The options are:

    #

    # * <tt>:conditions</tt>: An SQL fragment like "administrator = 1" or [
    "user_name = ?", username ]. See conditions in the intro.

    # * <tt>:order</tt>: An SQL fragment like "created_at DESC, name".

    # * <tt>:group</tt>: An attribute name by which the result should be grouped.
    Uses the GROUP BY SQL-clause.

    # * <tt>:limit</tt>: An integer determining the limit on the number of rows that
    should be returned.

    # * <tt>:offset</tt>: An integer determining the offset from where the rows
    should be fetched. So at 5, it would skip the first 4 rows.

    # * <tt>:joins</tt>: An SQL fragment for additional joins like "LEFT JOIN
    comments ON comments.post_id = id". (Rarely needed).

    #   The records will be returned read-only since they will have attributes that
    do not correspond to the table's columns.

    #   Pass :readonly => false to override.

    # * <tt>:include</tt>: Names associations that should be loaded alongside using
    LEFT OUTER JOINs. The symbols named refer

    #   to already defined associations. See eager loading under Associations.

    # * <tt>:select</tt>: By default, this is * as in SELECT * FROM, but can be
    changed if you for example want to do a join, but not

    #   include the joined columns.

    # * <tt>:readonly</tt>: Mark the returned records read-only so they cannot be
    saved or updated.

    #

    # Examples for find by id:

    #   Person.find(1)       # returns the object for ID = 1

    #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)

    #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)

    #   Person.find([1])     # returns an array for objects the object with ID = 1

    #   Person.find(1, :conditions => "administrator = 1", :order => "created_on
    DESC")

    #

    # Examples for find first:

    #   Person.find(:first) # returns the first object fetched by SELECT * FROM
    people

    #   Person.find(:first, :conditions => [ "user_name = ?", user_name])

    #   Person.find(:first, :order => "created_on DESC", :offset => 5)

    #

    # Examples for find all:

    #   Person.find(:all) # returns an array of objects for all the rows fetched by
    SELECT * FROM people

    #   Person.find(:all, :conditions => [ "category IN (?)", categories], :limit =>
    50)

    #   Person.find(:all, :offset => 10, :limit => 10)

    #   Person.find(:all, :include => [ :account, :friends ])

    #   Person.find(:all, :group => "category")

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 23
  ra_comment_id: 213
  visibility: 1
  name: find
  ra_container_id: 21
  parameters: "(*args)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 214
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 216
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 433
          def find_by_sql(sql)
            connection.select_all(sanitize_sql(sql), "#{name} Load").collect! { |record| instantiate(record) }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 215
  comment: >2
    # Works like find(:all), but requires a complete SQL string. Examples:

    #   Post.find_by_sql "SELECT p.*, c.author FROM posts p, comments c WHERE p.id =
    c.post_id"

    #   Post.find_by_sql ["SELECT * FROM posts WHERE author = ? AND created > ?",
    author_id, start_date]

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 24
  ra_comment_id: 215
  visibility: 1
  name: find_by_sql
  ra_container_id: 21
  parameters: "(sql)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 216
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 218
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 440
          def exists?(id)
            !find(:first, :conditions => ["#{primary_key} = ?", id]).nil? rescue false
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 217
  comment: >2
    # Returns true if the given +id+ represents the primary key of a record in the
    database, false otherwise.

    # Example:

    #   Person.exists?(5)

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 25
  ra_comment_id: 217
  visibility: 1
  name: "exists?"
  ra_container_id: 21
  parameters: "(id)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 218
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 220
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 446
          def create(attributes = nil)
            if attributes.is_a?(Array)
              attributes.collect { |attr| create(attr) }
            else
              attributes.reverse_merge!(scope(:create)) if scoped?(:create)

              object = new(attributes)
              object.save
              object
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 219
  comment: >2
    # Creates an object, instantly saves it as a record (if the validation permits
    it), and returns it. If the save

    # fails under validations, the unsaved object is still returned.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 26
  ra_comment_id: 219
  visibility: 1
  name: create
  ra_container_id: 21
  parameters: "(attributes = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 220
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 222
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 460
          def update(id, attributes)
            if id.is_a?(Array)
              idx = -1
              id.collect { |id| idx += 1; update(id, attributes[idx]) }
            else
              object = find(id)
              object.update_attributes(attributes)
              object
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 221
  comment: >2
    # Finds the record from the passed +id+, instantly saves it with the passed
    +attributes+ (if the validation permits it),

    # and returns it. If the save fails under validations, the unsaved object is
    still returned.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 27
  ra_comment_id: 221
  visibility: 1
  name: update
  ra_container_id: 21
  parameters: "(id, attributes)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 222
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 224
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 473
          def delete(id)
            delete_all([ "#{primary_key} IN (?)", id ])
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 223
  comment: >2
    # Deletes the record with the given +id+ without instantiating an object first.
    If an array of ids is provided, all of them

    # are deleted.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 28
  ra_comment_id: 223
  visibility: 1
  name: delete
  ra_container_id: 21
  parameters: "(id)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 224
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 226
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 479
          def destroy(id)
            id.is_a?(Array) ? id.each { |id| destroy(id) } : find(id).destroy
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 225
  comment: >2
    # Destroys the record with the given +id+ by instantiating the object and
    calling #destroy (all the callbacks are the triggered).

    # If an array of ids is provided, all of them are destroyed.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 29
  ra_comment_id: 225
  visibility: 1
  name: destroy
  ra_container_id: 21
  parameters: "(id)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 226
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 228
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 486
          def update_all(updates, conditions = nil)
            sql  = "UPDATE #{table_name} SET #{sanitize_sql(updates)} "
            add_conditions!(sql, conditions)
            connection.update(sql, "#{name} Update")
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 227
  comment: >2
    # Updates all records with the SET-part of an SQL update statement in +updates+
    and returns an integer with the number of rows updated.

    # A subset of the records can be selected by specifying +conditions+. Example:

    #   Billing.update_all "category = 'authorized', approved = 1", "author =
    'David'"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 30
  ra_comment_id: 227
  visibility: 1
  name: update_all
  ra_container_id: 21
  parameters: "(updates, conditions = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 228
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 230
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 495
          def destroy_all(conditions = nil)
            find(:all, :conditions => conditions).each { |object| object.destroy }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 229
  comment: >2
    # Destroys the objects for all the records that match the +condition+ by
    instantiating each object and calling

    # the destroy method. Example:

    #   Person.destroy_all "last_login < '2004-04-04'"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 31
  ra_comment_id: 229
  visibility: 1
  name: destroy_all
  ra_container_id: 21
  parameters: "(conditions = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 230
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 232
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 502
          def delete_all(conditions = nil)
            sql = "DELETE FROM #{table_name} "
            add_conditions!(sql, conditions)
            connection.delete(sql, "#{name} Delete all")
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 231
  comment: >2
    # Deletes all the records that match the +condition+ without instantiating the
    objects first (and hence not

    # calling the destroy method). Example:

    #   Post.delete_all "person_id = 5 AND (category = 'Something' OR category =
    'Else')"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 32
  ra_comment_id: 231
  visibility: 1
  name: delete_all
  ra_container_id: 21
  parameters: "(conditions = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 232
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 234
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 510
          def count(conditions = nil, joins = nil)
            sql  = "SELECT COUNT(*) FROM #{table_name} "
            sql << " #{joins} " if joins
            add_conditions!(sql, conditions)
            count_by_sql(sql)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 233
  comment: >2
    # Returns the number of records that meet the +conditions+. Zero is returned if
    no records match. Example:

    #   Product.count "sales > 1"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 33
  ra_comment_id: 233
  visibility: 1
  name: count
  ra_container_id: 21
  parameters: "(conditions = nil, joins = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 234
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 236
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 519
          def count_by_sql(sql)
            sql = sanitize_conditions(sql)
            connection.select_value(sql, "#{name} Count").to_i
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 235
  comment: >2
    # Returns the result of an SQL statement that should only include a COUNT(*) in
    the SELECT part.

    #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE
    s.customer_id = c.id"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 34
  ra_comment_id: 235
  visibility: 1
  name: count_by_sql
  ra_container_id: 21
  parameters: "(sql)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 236
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 238
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 529
          def increment_counter(counter_name, id)
            update_all "#{counter_name} = #{counter_name} + 1", "#{primary_key} = #{quote(id)}"
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 237
  comment: >2
    # Increments the specified counter by one. So
    <tt>DiscussionBoard.increment_counter("post_count",

    # discussion_board_id)</tt> would increment the "post_count" counter on the
    board responding to discussion_board_id.

    # This is used for caching aggregate values, so that they don't need to be
    computed every time. Especially important

    # for looping over a collection where each element require a number of aggregate
    values. Like the DiscussionBoard

    # that needs to list both the number of posts and comments.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 35
  ra_comment_id: 237
  visibility: 1
  name: increment_counter
  ra_container_id: 21
  parameters: "(counter_name, id)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 238
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 240
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 534
          def decrement_counter(counter_name, id)
            update_all "#{counter_name} = #{counter_name} - 1", "#{primary_key} = #{quote(id)}"
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 239
  comment: "# Works like increment_counter, but decrements instead.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 36
  ra_comment_id: 239
  visibility: 1
  name: decrement_counter
  ra_container_id: 21
  parameters: "(counter_name, id)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 240
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 242
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 553
          def attr_protected(*attributes)
            write_inheritable_array("attr_protected", attributes - (protected_attributes || []))
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 241
  comment: >2
    # Attributes named in this macro are protected from mass-assignment, such as
    <tt>new(attributes)</tt> and

    # <tt>attributes=(attributes)</tt>. Their assignment will simply be ignored.
    Instead, you can use the direct writer

    # methods to do assignment. This is meant to protect sensitive attributes from
    being overwritten by URL/form hackers. Example:

    #

    #   class Customer < ActiveRecord::Base

    #     attr_protected :credit_rating

    #   end

    #

    #   customer = Customer.new("name" => David, "credit_rating" => "Excellent")

    #   customer.credit_rating # => nil

    #   customer.attributes = { "description" => "Jolly fellow", "credit_rating" =>
    "Superb" }

    #   customer.credit_rating # => nil

    #

    #   customer.credit_rating = "Average"

    #   customer.credit_rating # => "Average"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 37
  ra_comment_id: 241
  visibility: 1
  name: attr_protected
  ra_container_id: 21
  parameters: "(*attributes)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 242
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 244
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 566
          def attr_accessible(*attributes)
            write_inheritable_array("attr_accessible", attributes - (accessible_attributes || []))
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 243
  comment: >2
    # If this macro is used, only those attributes named in it will be accessible
    for mass-assignment, such as

    # <tt>new(attributes)</tt> and <tt>attributes=(attributes)</tt>. This is the
    more conservative choice for mass-assignment

    # protection. If you'd rather start from an all-open default and restrict
    attributes as needed, have a look at

    # attr_protected.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 38
  ra_comment_id: 243
  visibility: 1
  name: attr_accessible
  ra_container_id: 21
  parameters: "(*attributes)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 244
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 246
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 578
          def serialize(attr_name, class_name = Object)
            serialized_attributes[attr_name.to_s] = class_name
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 245
  comment: >2
    # Specifies that the attribute by the name of +attr_name+ should be serialized
    before saving to the database and unserialized

    # after loading from the database. The serialization is done through YAML. If
    +class_name+ is specified, the serialized

    # object must be of that class on retrieval or +SerializationTypeMismatch+ will
    be raised.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 39
  ra_comment_id: 245
  visibility: 1
  name: serialize
  ra_container_id: 21
  parameters: "(attr_name, class_name = Object)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 246
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 248
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 583
          def serialized_attributes
            read_inheritable_attribute("attr_serialized") or write_inheritable_attribute("attr_serialized", {})
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 247
  comment: "# Returns a hash of all the attributes that have been specified for
serialization as keys and their class restriction as values.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 40
  ra_comment_id: 247
  visibility: 1
  name: serialized_attributes
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 248
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 250
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 601
          def table_name
            reset_table_name
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 249
  comment: >2
    # Guesses the table name (in forced lower-case) based on the name of the class
    in the inheritance hierarchy descending

    # directly from ActiveRecord. So if the hierarchy looks like: Reply < Message <
    ActiveRecord, then Message is used

    # to guess the table name from even when called on Reply. The rules used to do
    the guess are handled by the Inflector class

    # in Active Support, which knows almost all common English inflections (report a
    bug if your inflection isn't covered).

    #

    # Additionally, the class-level table_name_prefix is prepended to the table_name
    and the table_name_suffix is appended.

    # So if you have "myapp_" as a prefix, the table name guess for an Account class
    becomes "myapp_accounts".

    #

    # You can also overwrite this class method to allow for unguessable links, such
    as a Mouse class with a link to a

    # "mice" table. Example:

    #

    #   class Mouse < ActiveRecord::Base

    #      set_table_name "mice"

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 41
  ra_comment_id: 249
  visibility: 1
  name: table_name
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 250
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 252
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 605
          def reset_table_name
            name = "#{table_name_prefix}#{undecorated_table_name(class_name_of_active_record_descendant(self))}#{table_name_suffix}"
            set_table_name name
            name
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 251
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 42
  ra_comment_id: 251
  visibility: 1
  name: reset_table_name
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 252
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 254
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 613
          def primary_key
            reset_primary_key
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 253
  comment: >2
    # Defines the primary key field -- can be overridden in subclasses. Overwriting
    will negate any effect of the

    # primary_key_prefix_type setting, though.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 43
  ra_comment_id: 253
  visibility: 1
  name: primary_key
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 254
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 256
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 617
          def reset_primary_key
            key = 'id'
            case primary_key_prefix_type
              when :table_name
                key = Inflector.foreign_key(class_name_of_active_record_descendant(self), false)
              when :table_name_with_underscore
                key = Inflector.foreign_key(class_name_of_active_record_descendant(self))
            end
            set_primary_key(key)
            key
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 255
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 44
  ra_comment_id: 255
  visibility: 1
  name: reset_primary_key
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 256
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 258
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 630
          def inheritance_column
            "type"
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 257
  comment: "# Defines the column name for use with single table inheritance -- can be
overridden in subclasses.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 45
  ra_comment_id: 257
  visibility: 1
  name: inheritance_column
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 258
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 260
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 636
          def sequence_name
            reset_sequence_name
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 259
  comment: >2
    # Lazy-set the sequence name to the connection's default.  This method

    # is only ever called once since set_sequence_name overrides it.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 46
  ra_comment_id: 259
  visibility: 1
  name: sequence_name
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 260
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 262
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 640
          def reset_sequence_name
            default = connection.default_sequence_name(table_name, primary_key)
            set_sequence_name(default)
            default
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 261
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 47
  ra_comment_id: 261
  visibility: 1
  name: reset_sequence_name
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 262
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 264
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 654
          def set_table_name( value=nil, &block )
            define_attr_method :table_name, value, &block
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 263
  comment: >2
    # Sets the table name to use to the given value, or (if the value

    # is nil or false) to the value returned by the given block.

    #

    # Example:

    #

    #   class Project < ActiveRecord::Base

    #     set_table_name "project"

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 48
  ra_comment_id: 263
  visibility: 1
  name: set_table_name
  ra_container_id: 21
  parameters: "( value=nil, &block )"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 264
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 266
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 668
          def set_primary_key( value=nil, &block )
            define_attr_method :primary_key, value, &block
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 265
  comment: >2
    # Sets the name of the primary key column to use to the given value,

    # or (if the value is nil or false) to the value returned by the given

    # block.

    #

    # Example:

    #

    #   class Project < ActiveRecord::Base

    #     set_primary_key "sysid"

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 49
  ra_comment_id: 265
  visibility: 1
  name: set_primary_key
  ra_container_id: 21
  parameters: "( value=nil, &block )"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 266
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 268
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 684
          def set_inheritance_column( value=nil, &block )
            define_attr_method :inheritance_column, value, &block
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 267
  comment: >2
    # Sets the name of the inheritance column to use to the given value,

    # or (if the value # is nil or false) to the value returned by the

    # given block.

    #

    # Example:

    #

    #   class Project < ActiveRecord::Base

    #     set_inheritance_column do

    #       original_inheritance_column + "_id"

    #     end

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 50
  ra_comment_id: 267
  visibility: 1
  name: set_inheritance_column
  ra_container_id: 21
  parameters: "( value=nil, &block )"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 268
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 270
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 705
          def set_sequence_name( value=nil, &block )
            define_attr_method :sequence_name, value, &block
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 269
  comment: >2
    # Sets the name of the sequence to use when generating ids to the given

    # value, or (if the value is nil or false) to the value returned by the

    # given block. This is required for Oracle and is useful for any

    # database which relies on sequences for primary key generation.

    #

    # If a sequence name is not explicitly set when using Oracle or Firebird,

    # it will default to the commonly used pattern of: #{table_name}_seq

    #

    # If a sequence name is not explicitly set when using PostgreSQL, it

    # will discover the sequence corresponding to your primary key for you.

    #

    # Example:

    #

    #   class Project < ActiveRecord::Base

    #     set_sequence_name "projectseq"   # default would have been "project_seq"

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 51
  ra_comment_id: 269
  visibility: 1
  name: set_sequence_name
  ra_container_id: 21
  parameters: "( value=nil, &block )"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 270
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 272
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 719
          def table_exists?
            if connection.respond_to?(:tables)
              connection.tables.include? table_name
            else
              # if the connection adapter hasn't implemented tables, there are two crude tests that can be
              # used - see if getting column info raises an error, or if the number of columns returned is zero
              begin
                reset_column_information
                columns.size > 0
              rescue ActiveRecord::StatementInvalid
                false
              end          
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 271
  comment: "# Indicates whether the table associated with this class exists

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 52
  ra_comment_id: 271
  visibility: 1
  name: "table_exists?"
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 272
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 274
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 735
          def columns
            unless @columns
              @columns = connection.columns(table_name, "#{name} Columns")
              @columns.each {|column| column.primary = column.name == primary_key}
            end
            @columns
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 273
  comment: "# Returns an array of column objects for the table associated with this class.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 53
  ra_comment_id: 273
  visibility: 1
  name: columns
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 274
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 276
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 744
          def columns_hash
            @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 275
  comment: "# Returns an array of column objects for the table associated with this class.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 54
  ra_comment_id: 275
  visibility: 1
  name: columns_hash
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 276
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 278
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 748
          def column_names
            @column_names ||= columns.map { |column| column.name }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 277
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 55
  ra_comment_id: 277
  visibility: 1
  name: column_names
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 278
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 280
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 754
          def content_columns
            @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 279
  comment: >2
    # Returns an array of column objects where the primary id, all columns ending in
    "_id" or "_count",

    # and columns used for single table inheritance have been removed.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 56
  ra_comment_id: 279
  visibility: 1
  name: content_columns
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 280
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 282
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 761
          def column_methods_hash
            @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
              attr_name = attr.to_s
              methods[attr.to_sym]       = attr_name
              methods["#{attr}=".to_sym] = attr_name
              methods["#{attr}?".to_sym] = attr_name
              methods["#{attr}_before_type_cast".to_sym] = attr_name
              methods
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 281
  comment: >2
    # Returns a hash of all the methods added to query each of the columns in the
    table with the name of the method as the key

    # and true as the value. This makes it possible to do O(1) lookups in
    respond_to? to check if a given method for attribute

    # is available.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 57
  ra_comment_id: 281
  visibility: 1
  name: column_methods_hash
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 282
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 284
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 773
          def read_methods
            @read_methods ||= Set.new
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 283
  comment: "# Contains the names of the generated reader methods.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 58
  ra_comment_id: 283
  visibility: 1
  name: read_methods
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 284
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 286
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 778
          def reset_column_information
            read_methods.each { |name| undef_method(name) }
            @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @read_methods = nil
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 285
  comment: "# Resets all the cached information about columns, which will cause them to be
reloaded on the next request.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 59
  ra_comment_id: 285
  visibility: 1
  name: reset_column_information
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 286
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 288
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 820
          def benchmark(title, log_level = Logger::DEBUG, use_silence = true)
            if logger && logger.level == log_level
              result = nil
              seconds = Benchmark.realtime { result = use_silence ? silence { yield } : yield }
              logger.add(log_level, "#{title} (#{'%.5f' % seconds})")
              result
            else
              yield
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 287
  comment: >2
    # Log and benchmark multiple statements in a single block. Example:

    #

    #   Project.benchmark("Creating project") do

    #     project = Project.create("name" => "stuff")

    #     project.create_manager("name" => "David")

    #     project.milestones << Milestone.find(:all)

    #   end

    #

    # The benchmark is only recorded if the current level of the logger matches the
    <tt>log_level</tt>, which makes it

    # easy to include benchmarking statements in production software that will
    remain inexpensive because the benchmark

    # will only be conducted if the log level is low enough.

    #

    # The logging of the multiple statements is turned off unless
    <tt>use_silence</tt> is set to false.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 60
  ra_comment_id: 287
  visibility: 1
  name: benchmark
  ra_container_id: 21
  parameters: "(title, log_level = Logger::DEBUG, use_silence = true)"
  singleton: 1
  force_documentation: 0
  block_parameters: ''
  ra_source_code_id: 288
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 290
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 832
          def silence
            old_logger_level, logger.level = logger.level, Logger::ERROR if logger
            yield
          ensure
            logger.level = old_logger_level if logger
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 289
  comment: "# Silences the logger for the duration of the block.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 61
  ra_comment_id: 289
  visibility: 1
  name: silence
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: ''
  ra_source_code_id: 290
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 292
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 850
          def with_scope(method_scoping = {})
            # Dup first and second level of hash (method and params).
            method_scoping = method_scoping.inject({}) do |hash, (method, params)|
              hash[method] = params.dup
              hash
            end

            method_scoping.assert_valid_keys [:find, :create]
            if f = method_scoping[:find]
              f.assert_valid_keys [:conditions, :joins, :offset, :limit, :readonly]
              f[:readonly] = true if !f[:joins].blank? && !f.has_key?(:readonly)
            end

            raise ArgumentError, "Nested scopes are not yet supported: #{scoped_methods.inspect}" unless scoped_methods.nil?

            self.scoped_methods = method_scoping
            yield
          ensure 
            self.scoped_methods = nil
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 291
  comment: >2
    # Scope parameters to method calls within the block.  Takes a hash of
    method_name => parameters hash.

    # method_name may be :find or :create.

    # :find parameters may include the <tt>:conditions</tt>, <tt>:joins</tt>,

    # <tt>:offset</tt>, <tt>:limit</tt>, and <tt>:readonly</tt> options.

    # :create parameters are an attributes hash.

    #

    #   Article.with_scope(:find => { :conditions => "blog_id = 1" }, :create => {
    :blog_id => 1 }) do

    #     Article.find(1) # => SELECT * from articles WHERE blog_id = 1 AND id = 1

    #     a = Article.create(1)

    #     a.blog_id == 1

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 62
  ra_comment_id: 291
  visibility: 1
  name: with_scope
  ra_container_id: 21
  parameters: "(method_scoping = {})"
  singleton: 1
  force_documentation: 0
  block_parameters: ''
  ra_source_code_id: 292
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 294
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 872
          def ===(object)
            object.is_a?(self)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 293
  comment: "# Overwrite the default class equality method to provide support for association
proxies.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 63
  ra_comment_id: 293
  visibility: 1
  name: "==="
  ra_container_id: 21
  parameters: "(object)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 294
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 296
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 877
          def threaded_connections
            allow_concurrency
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 295
  comment: "# Deprecated 

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 64
  ra_comment_id: 295
  visibility: 1
  name: threaded_connections
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 296
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 298
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 882
          def threaded_connections=(value)
            self.allow_concurrency = value
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 297
  comment: "# Deprecated 

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 65
  ra_comment_id: 297
  visibility: 1
  name: threaded_connections=
  ra_container_id: 21
  parameters: "(value)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 298
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 300
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 890
            def instantiate(record)
              object = 
                if subclass_name = record[inheritance_column]
                  if subclass_name.empty?
                    allocate
                  else
                    require_association_class(subclass_name)
                    begin
                      compute_type(subclass_name).allocate
                    rescue NameError
                      raise SubclassNotFound,
                        "The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. " +
                        "This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. " +
                        "Please rename this column if you didn't intend it to be used for storing the inheritance class " +
                        "or overwrite #{self.to_s}.inheritance_column to use another column for that information."
                    end
                  end
                else
                  allocate
                end

              object.instance_variable_set("@attributes", record)
              object
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 299
  comment: >2
    # Finder methods must instantiate through this method to work with the
    single-table inheritance model

    # that makes it possible to create objects of different types from the same
    table.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 66
  ra_comment_id: 299
  visibility: 2
  name: instantiate
  ra_container_id: 21
  parameters: "(record)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 300
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 302
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 917
            def type_name_with_module(type_name)
              self.name =~ /::/ ? self.name.scan(/(.*)::/).first.first + "::" + type_name : type_name
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 301
  comment: >2
    # Returns the name of the type of the record using the current module as a
    prefix. So descendents of

    # MyApp::Business::Account would appear as "MyApp::Business::AccountSubclass".

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 67
  ra_comment_id: 301
  visibility: 2
  name: type_name_with_module
  ra_container_id: 21
  parameters: "(type_name)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 302
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 304
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 921
            def construct_finder_sql(options)
              sql  = "SELECT #{options[:select] || '*'} FROM #{table_name} "
              add_joins!(sql, options)
              add_conditions!(sql, options[:conditions])
              sql << " GROUP BY #{options[:group]} " if options[:group]
              sql << " ORDER BY #{options[:order]} " if options[:order]
              add_limit!(sql, options)
              sql
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 303
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 68
  ra_comment_id: 303
  visibility: 2
  name: construct_finder_sql
  ra_container_id: 21
  parameters: "(options)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 304
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 306
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 931
            def add_limit!(sql, options)
              options[:limit]  ||= scope(:find, :limit)
              options[:offset] ||= scope(:find, :offset)
              connection.add_limit_offset!(sql, options)
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 305
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 69
  ra_comment_id: 305
  visibility: 2
  name: add_limit!
  ra_container_id: 21
  parameters: "(sql, options)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 306
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 308
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 937
            def add_joins!(sql, options)
              join = scope(:find, :joins) || options[:joins]
              sql << " #{join} " if join
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 307
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 70
  ra_comment_id: 307
  visibility: 2
  name: add_joins!
  ra_container_id: 21
  parameters: "(sql, options)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 308
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 310
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 943
            def add_conditions!(sql, conditions)          
              segments = [scope(:find, :conditions)]
              segments << sanitize_sql(conditions) unless conditions.nil?
              segments << type_condition unless descends_from_active_record?        
              segments.compact!
              sql << "WHERE (#{segments.join(") AND (")}) " unless segments.empty?
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 309
  comment: "# Adds a sanitized version of +conditions+ to the +sql+ string. Note that the
passed-in +sql+ string is changed.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 71
  ra_comment_id: 309
  visibility: 2
  name: add_conditions!
  ra_container_id: 21
  parameters: "(sql, conditions)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 310
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 312
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 951
            def type_condition
              quoted_inheritance_column = connection.quote_column_name(inheritance_column)
              type_condition = subclasses.inject("#{table_name}.#{quoted_inheritance_column} = '#{name.demodulize}' ") do |condition, subclass|
                condition << "OR #{table_name}.#{quoted_inheritance_column} = '#{subclass.name.demodulize}' "
              end

              " (#{type_condition}) "
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 311
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 72
  ra_comment_id: 311
  visibility: 2
  name: type_condition
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 312
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 314
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 961
            def undecorated_table_name(class_name = class_name_of_active_record_descendant(self))
              table_name = Inflector.underscore(Inflector.demodulize(class_name))
              table_name = Inflector.pluralize(table_name) if pluralize_table_names
              table_name
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 313
  comment: "# Guesses the table name, but does not decorate it with prefix and suffix
information.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 73
  ra_comment_id: 313
  visibility: 2
  name: undecorated_table_name
  ra_container_id: 21
  parameters: "(class_name = class_name_of_active_record_descendant(self))"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 314
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 316
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 973
            def method_missing(method_id, *arguments)
              if match = /find_(all_by|by)_([_a-zA-Z]\w*)/.match(method_id.to_s)
                finder = determine_finder(match)

                attribute_names = extract_attribute_names_from_match(match)
                super unless all_attributes_exists?(attribute_names)

                conditions = construct_conditions_from_arguments(attribute_names, arguments)

                if arguments[attribute_names.length].is_a?(Hash)
                  find(finder, { :conditions => conditions }.update(arguments[attribute_names.length]))
                else
                  send("find_#{finder}", conditions, *arguments[attribute_names.length..-1]) # deprecated API
                end
              elsif match = /find_or_create_by_([_a-zA-Z]\w*)/.match(method_id.to_s)
                attribute_names = extract_attribute_names_from_match(match)
                super unless all_attributes_exists?(attribute_names)

                find(:first, :conditions => construct_conditions_from_arguments(attribute_names, arguments)) || 
                  create(construct_attributes_from_arguments(attribute_names, arguments))
              else
                super
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 315
  comment: >2
    # Enables dynamic finders like find_by_user_name(user_name) and
    find_by_user_name_and_password(user_name, password) that are turned into

    # find(:first, :conditions => ["user_name = ?", user_name]) and  find(:first,
    :conditions => ["user_name = ? AND password = ?", user_name, password])

    # respectively. Also works for find(:all), but using find_all_by_amount(50) that
    are turned into find(:all, :conditions => ["amount = ?", 50]).

    #

    # It's even possible to use all the additional parameters to find. For example,
    the full interface for find_all_by_amount

    # is actually find_all_by_amount(amount, options).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 74
  ra_comment_id: 315
  visibility: 2
  name: method_missing
  ra_container_id: 21
  parameters: "(method_id, *arguments)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 316
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 318
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 998
            def determine_finder(match)
              match.captures.first == 'all_by' ? :all : :first
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 317
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 75
  ra_comment_id: 317
  visibility: 2
  name: determine_finder
  ra_container_id: 21
  parameters: "(match)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 318
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 320
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1002
            def extract_attribute_names_from_match(match)
              match.captures.last.split('_and_')
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 319
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 76
  ra_comment_id: 319
  visibility: 2
  name: extract_attribute_names_from_match
  ra_container_id: 21
  parameters: "(match)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 320
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 322
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1006
            def construct_conditions_from_arguments(attribute_names, arguments)
              conditions = []
              attribute_names.each_with_index { |name, idx| conditions << "#{table_name}.#{connection.quote_column_name(name)} #{attribute_condition(arguments[idx])} " }
              [ conditions.join(" AND "), *arguments[0...attribute_names.length] ]
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 321
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 77
  ra_comment_id: 321
  visibility: 2
  name: construct_conditions_from_arguments
  ra_container_id: 21
  parameters: "(attribute_names, arguments)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 322
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 324
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1012
            def construct_attributes_from_arguments(attribute_names, arguments)
              attributes = {}
              attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }
              attributes
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 323
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 78
  ra_comment_id: 323
  visibility: 2
  name: construct_attributes_from_arguments
  ra_container_id: 21
  parameters: "(attribute_names, arguments)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 324
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 326
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1018
            def all_attributes_exists?(attribute_names)
              attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 325
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 79
  ra_comment_id: 325
  visibility: 2
  name: "all_attributes_exists?"
  ra_container_id: 21
  parameters: "(attribute_names)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 326
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 328
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1022
            def attribute_condition(argument)
              case argument
                when nil   then "IS ?"
                when Array then "IN (?)"
                else            "= ?"
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 327
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 80
  ra_comment_id: 327
  visibility: 2
  name: attribute_condition
  ra_container_id: 21
  parameters: "(argument)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 328
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 330
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1048
            def define_attr_method(name, value=nil, &block)
              sing = class << self; self; end
              sing.send :alias_method, "original_#{name}", name
              if block_given?
                sing.send :define_method, name, &block
              else
                # use eval instead of a block to work around a memory leak in dev
                # mode in fcgi
                sing.class_eval "def #{name}; #{value.to_s.inspect}; end"
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 329
  comment: >2
    # Defines an "attribute" method (like #inheritance_column or

    # #table_name). A new (class) method will be created with the

    # given name. If a value is specified, the new method will

    # return that value (as a string). Otherwise, the given block

    # will be used to compute the value of the method.

    #

    # The original method will be aliased, with the new name being

    # prefixed with "original_". This allows the new method to

    # access the original value.

    #

    # Example:

    #

    #   class A < ActiveRecord::Base

    #     define_attr_method :primary_key, "sysid"

    #     define_attr_method( :inheritance_column ) do

    #       original_inheritance_column + "_id"

    #     end

    #   end

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 81
  ra_comment_id: 329
  visibility: 2
  name: define_attr_method
  ra_container_id: 21
  parameters: "(name, value=nil, &block)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 330
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 332
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1061
            def subclasses
              @@subclasses[self] ||= []
              @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 331
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 82
  ra_comment_id: 331
  visibility: 3
  name: subclasses
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 332
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 334
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1067
            def scoped?(method, key = nil)
              scoped_methods and scoped_methods.has_key?(method) and (key.nil? or scope(method).has_key?(key))
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 333
  comment: "# Test whether the given method and optional key are scoped.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 83
  ra_comment_id: 333
  visibility: 3
  name: "scoped?"
  ra_container_id: 21
  parameters: "(method, key = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 334
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 336
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1072
            def scope(method, key = nil)
              if scoped_methods and scope = scoped_methods[method]
                key ? scope[key] : scope
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 335
  comment: "# Retrieve the scope for the given method and optional key.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 84
  ra_comment_id: 335
  visibility: 3
  name: scope
  ra_container_id: 21
  parameters: "(method, key = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 336
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 338
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1078
            def scoped_methods
              if allow_concurrency
                Thread.current[:scoped_methods] ||= {}
                Thread.current[:scoped_methods][self] ||= nil
              else
                @scoped_methods ||= nil
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 337
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 85
  ra_comment_id: 337
  visibility: 3
  name: scoped_methods
  ra_container_id: 21
  parameters: "()"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 338
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 340
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1087
            def scoped_methods=(value)
              if allow_concurrency
                Thread.current[:scoped_methods] ||= {}
                Thread.current[:scoped_methods][self] = value
              else
                @scoped_methods = value
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 339
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 86
  ra_comment_id: 339
  visibility: 3
  name: scoped_methods=
  ra_container_id: 21
  parameters: "(value)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 340
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 342
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1098
            def compute_type(type_name)
              type_name_with_module(type_name).split("::").inject(Object) do |final_type, part|
                final_type.const_get(part)
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 341
  comment: >2
    # Returns the class type of the record using the current module as a prefix. So
    descendents of

    # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 87
  ra_comment_id: 341
  visibility: 3
  name: compute_type
  ra_container_id: 21
  parameters: "(type_name)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 342
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 344
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1105
            def class_name_of_active_record_descendant(klass)
              if klass.superclass == Base
                klass.name
              elsif klass.superclass.nil?
                raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
              else
                class_name_of_active_record_descendant(klass.superclass)
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 343
  comment: "# Returns the name of the class descending directly from ActiveRecord in the
inheritance hierarchy.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 88
  ra_comment_id: 343
  visibility: 3
  name: class_name_of_active_record_descendant
  ra_container_id: 21
  parameters: "(klass)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 344
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 346
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1118
            def sanitize_sql(ary)
              return ary unless ary.is_a?(Array)

              statement, *values = ary
              if values.first.is_a?(Hash) and statement =~ /:\w+/
                replace_named_bind_variables(statement, values.first)
              elsif statement.include?('?')
                replace_bind_variables(statement, values)
              else
                statement % values.collect { |value| connection.quote_string(value.to_s) }
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 345
  comment: >2
    # Accepts an array or string.  The string is returned untouched, but the array
    has each value

    # sanitized and interpolated into the sql statement.

    #   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and
    group_id='4'"

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 89
  ra_comment_id: 345
  visibility: 3
  name: sanitize_sql
  ra_container_id: 21
  parameters: "(ary)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 346
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 348
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1133
            def replace_bind_variables(statement, values)
              raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)
              bound = values.dup
              statement.gsub('?') { quote_bound_value(bound.shift) }
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 347
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 90
  ra_comment_id: 347
  visibility: 3
  name: replace_bind_variables
  ra_container_id: 21
  parameters: "(statement, values)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 348
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 350
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1139
            def replace_named_bind_variables(statement, bind_vars)
              raise_if_bind_arity_mismatch(statement, statement.scan(/:(\w+)/).uniq.size, bind_vars.size)
              statement.gsub(/:(\w+)/) do
                match = $1.to_sym
                if bind_vars.include?(match)
                  quote_bound_value(bind_vars[match])
                else
                  raise PreparedStatementInvalid, "missing value for :#{match} in #{statement}"
                end
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 349
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 91
  ra_comment_id: 349
  visibility: 3
  name: replace_named_bind_variables
  ra_container_id: 21
  parameters: "(statement, bind_vars)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 350
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 352
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1151
            def quote_bound_value(value)
              if (value.respond_to?(:map) && !value.is_a?(String))
                value.map { |v| connection.quote(v) }.join(',')
              else
                connection.quote(value)
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 351
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 92
  ra_comment_id: 351
  visibility: 3
  name: quote_bound_value
  ra_container_id: 21
  parameters: "(value)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 352
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 354
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1159
            def raise_if_bind_arity_mismatch(statement, expected, provided)
              unless expected == provided
                raise PreparedStatementInvalid, "wrong number of bind variables (#{provided} for #{expected}) in: #{statement}"
              end
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 353
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 93
  ra_comment_id: 353
  visibility: 3
  name: raise_if_bind_arity_mismatch
  ra_container_id: 21
  parameters: "(statement, expected, provided)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 354
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 356
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1165
            def extract_options_from_args!(args)
              options = args.last.is_a?(Hash) ? args.pop : {}
              validate_find_options(options)
              options
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 355
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 94
  ra_comment_id: 355
  visibility: 3
  name: extract_options_from_args!
  ra_container_id: 21
  parameters: "(args)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 356
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 358
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1171
            def validate_find_options(options)
              options.assert_valid_keys [:conditions, :include, :joins, :limit, :offset, :order, :select, :readonly, :group]
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 357
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 95
  ra_comment_id: 357
  visibility: 3
  name: validate_find_options
  ra_container_id: 21
  parameters: "(options)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 358
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 360
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1175
            def encode_quoted_value(value)
              quoted_value = connection.quote(value)
              quoted_value = "'#{quoted_value[1..-2].gsub(/\'/, "\\\\'")}'" if quoted_value.include?("\\\'") # (for ruby mode) " 
              quoted_value 
            end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 359
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 96
  ra_comment_id: 359
  visibility: 3
  name: encode_quoted_value
  ra_container_id: 21
  parameters: "(value)"
  singleton: 1
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 360
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 362
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1187
          def initialize(attributes = nil)
            @attributes = attributes_from_column_definition
            @new_record = true
            ensure_proper_type
            self.attributes = attributes unless attributes.nil?
            yield self if block_given?
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 361
  comment: >2
    # New objects can be instantiated as either empty (pass no construction
    parameter) or pre-set with

    # attributes but not yet saved (pass a hash with key names matching the
    associated table column names).

    # In both instances, valid attribute keys are determined by the column names of
    the associated table --

    # hence you can't have attributes that aren't part of the table columns.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 97
  ra_comment_id: 361
  visibility: 1
  name: new
  ra_container_id: 21
  parameters: "(attributes = nil)"
  singleton: 1
  force_documentation: 0
  block_parameters: "self if block_given?"
  ra_source_code_id: 362
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 364
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1197
          def id
            attr_name = self.class.primary_key
            column = column_for_attribute(attr_name)
            define_read_method(:id, attr_name, column) if self.class.generate_read_methods
            read_attribute(attr_name)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 363
  comment: >2
    # A model instance's primary key is always available as model.id

    # whether you name it the default 'id' or set it to something else.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 98
  ra_comment_id: 363
  visibility: 1
  name: id
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 364
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 366
  source_code: ''
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 365
  comment: "Alias for #id"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 99
  ra_comment_id: 365
  visibility: 1
  name: to_param
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 366
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 368
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1216
          def id=(value)
            write_attribute(self.class.primary_key, value)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 367
  comment: "# Sets the primary ID.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 100
  ra_comment_id: 367
  visibility: 1
  name: id=
  ra_container_id: 21
  parameters: "(value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 368
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 370
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1221
          def new_record?
            @new_record
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 369
  comment: "# Returns true if this object hasn't been saved yet -- that is, a record for the
object doesn't exist yet.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 101
  ra_comment_id: 369
  visibility: 1
  name: "new_record?"
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 370
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 372
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1227
          def save
            raise ActiveRecord::ReadOnlyRecord if readonly?
            create_or_update
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 371
  comment: >2
    # * No record exists: Creates a new record with values matching those of the
    object attributes.

    # * A record does exist: Updates the record with values matching those of the
    object attributes.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 102
  ra_comment_id: 371
  visibility: 1
  name: save
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 372
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 374
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1234
          def destroy
            unless new_record?
              connection.delete "DELETE FROM \#{self.class.table_name}\nWHERE \#{self.class.primary_key} = \#{quoted_id}\n", "#{self.class.name} Destroy"
            end

            freeze
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 373
  comment: >2
    # Deletes the record in the database and freezes this instance to reflect that
    no changes should

    # be made (since they can't be persisted).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 103
  ra_comment_id: 373
  visibility: 1
  name: destroy
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 374
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 376
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1251
          def clone
            attrs = self.attributes_before_type_cast
            attrs.delete(self.class.primary_key)
            self.class.new do |record|
              record.send :instance_variable_set, '@attributes', attrs
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 375
  comment: >2
    # Returns a clone of the record that hasn't been assigned an id yet and

    # is treated as a new record.  Note that this is a "shallow" clone:

    # it copies the object's attributes only, not its associations.

    # The extent of a "deep" clone is application-specific and is therefore

    # left to the application to implement according to its need.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 104
  ra_comment_id: 375
  visibility: 1
  name: clone
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 376
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 378
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1262
          def update_attribute(name, value)
            send(name.to_s + '=', value)
            save
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 377
  comment: >2
    # Updates a single attribute and saves the record. This is especially useful for
    boolean flags on existing records.

    # Note: This method is overwritten by the Validation module that'll make sure
    that updates made with this method

    # doesn't get subjected to validation checks. Hence, attributes can be updated
    even if the full object isn't valid.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 105
  ra_comment_id: 377
  visibility: 1
  name: update_attribute
  ra_container_id: 21
  parameters: "(name, value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 378
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 380
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1269
          def update_attributes(attributes)
            self.attributes = attributes
            save
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 379
  comment: >2
    # Updates all the attributes from the passed-in Hash and saves the record. If
    the object is invalid, the saving will

    # fail and false will be returned.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 106
  ra_comment_id: 379
  visibility: 1
  name: update_attributes
  ra_container_id: 21
  parameters: "(attributes)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 380
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 382
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1275
          def increment(attribute)
            self[attribute] ||= 0
            self[attribute] += 1
            self
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 381
  comment: "# Initializes the +attribute+ to zero if nil and adds one. Only makes sense for
number-based attributes. Returns self.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 107
  ra_comment_id: 381
  visibility: 1
  name: increment
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 382
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 384
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1282
          def increment!(attribute)
            increment(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 383
  comment: "# Increments the +attribute+ and saves the record.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 108
  ra_comment_id: 383
  visibility: 1
  name: increment!
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 384
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 386
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1287
          def decrement(attribute)
            self[attribute] ||= 0
            self[attribute] -= 1
            self
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 385
  comment: "# Initializes the +attribute+ to zero if nil and subtracts one. Only makes sense
for number-based attributes. Returns self.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 109
  ra_comment_id: 385
  visibility: 1
  name: decrement
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 386
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 388
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1294
          def decrement!(attribute)
            decrement(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 387
  comment: "# Decrements the +attribute+ and saves the record.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 110
  ra_comment_id: 387
  visibility: 1
  name: decrement!
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 388
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 390
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1299
          def toggle(attribute)
            self[attribute] = !send("#{attribute}?")
            self
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 389
  comment: "# Turns an +attribute+ that's currently true into false and vice versa. Returns
self.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 111
  ra_comment_id: 389
  visibility: 1
  name: toggle
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 390
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 392
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1305
          def toggle!(attribute)
            toggle(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 391
  comment: "# Toggles the +attribute+ and saves the record.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 112
  ra_comment_id: 391
  visibility: 1
  name: toggle!
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 392
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 394
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1310
          def reload
            clear_aggregation_cache
            clear_association_cache
            @attributes.update(self.class.find(self.id).instance_variable_get('@attributes'))
            self
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 393
  comment: "# Reloads the attributes of this object from the database.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 113
  ra_comment_id: 393
  visibility: 1
  name: reload
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 394
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 396
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1320
          def [](attr_name)
            read_attribute(attr_name)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 395
  comment: >2
    # Returns the value of the attribute identified by <tt>attr_name</tt> after it
    has been typecast (for example,

    # "2004-12-12" in a data column is cast to a date object, like Date.new(2004,
    12, 12)).

    # (Alias for the protected read_attribute method).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 114
  ra_comment_id: 395
  visibility: 1
  name: "[]"
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 396
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 398
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1326
          def []=(attr_name, value)
            write_attribute(attr_name, value)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 397
  comment: >2
    # Updates the attribute identified by <tt>attr_name</tt> with the specified
    +value+.

    # (Alias for the protected write_attribute method).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 115
  ra_comment_id: 397
  visibility: 1
  name: "[]="
  ra_container_id: 21
  parameters: "(attr_name, value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 398
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 400
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1335
          def attributes=(attributes)
            return if attributes.nil?
            attributes.stringify_keys!

            multi_parameter_attributes = []
            remove_attributes_protected_from_mass_assignment(attributes).each do |k, v|
              k.include?("(") ? multi_parameter_attributes << [ k, v ] : send(k + "=", v)
            end
            assign_multiparameter_attributes(multi_parameter_attributes)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 399
  comment: >2
    # Allows you to set all the attributes at once by passing in a hash with keys

    # matching the attribute names (which again matches the column names). Sensitive
    attributes can be protected

    # from this form of mass-assignment by using the +attr_protected+ macro. Or you
    can alternatively

    # specify which attributes *can* be accessed in with the +attr_accessible+
    macro. Then all the

    # attributes not included in that won't be allowed to be mass-assigned.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 116
  ra_comment_id: 399
  visibility: 1
  name: attributes=
  ra_container_id: 21
  parameters: "(attributes)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 400
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 402
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1347
          def attributes
            clone_attributes :read_attribute
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 401
  comment: "# Returns a hash of all the attributes with their names as keys and clones of
their objects as values.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 117
  ra_comment_id: 401
  visibility: 1
  name: attributes
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 402
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 404
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1352
          def attributes_before_type_cast
            clone_attributes :read_attribute_before_type_cast
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 403
  comment: "# Returns a hash of cloned attributes before typecasting and deserialization.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 118
  ra_comment_id: 403
  visibility: 1
  name: attributes_before_type_cast
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 404
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 406
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1358
          def attribute_present?(attribute)
            value = read_attribute(attribute)
            !value.blank? or value == 0
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 405
  comment: >2
    # Returns true if the specified +attribute+ has been set by the user or by a
    database load and is neither

    # nil nor empty? (the latter only applies to objects that respond to empty?,
    most notably Strings).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 119
  ra_comment_id: 405
  visibility: 1
  name: "attribute_present?"
  ra_container_id: 21
  parameters: "(attribute)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 406
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 408
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1364
          def has_attribute?(attr_name)
            @attributes.has_key?(attr_name.to_s)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 407
  comment: "# Returns true if the given attribute is in the attributes hash

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 120
  ra_comment_id: 407
  visibility: 1
  name: "has_attribute?"
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 408
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 410
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1369
          def attribute_names
            @attributes.keys.sort
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 409
  comment: "# Returns an array of names for the attributes available on this object sorted
alphabetically.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 121
  ra_comment_id: 409
  visibility: 1
  name: attribute_names
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 410
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 412
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1374
          def column_for_attribute(name)
            self.class.columns_hash[name.to_s]
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 411
  comment: "# Returns the column object for the named attribute.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 122
  ra_comment_id: 411
  visibility: 1
  name: column_for_attribute
  ra_container_id: 21
  parameters: "(name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 412
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 414
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1379
          def ==(comparison_object)
            comparison_object.equal?(self) ||
              (comparison_object.instance_of?(self.class) && 
                comparison_object.id == id && 
                !comparison_object.new_record?)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 413
  comment: "# Returns true if the +comparison_object+ is the same object, or is of the same
type and has the same id.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 123
  ra_comment_id: 413
  visibility: 1
  name: "=="
  ra_container_id: 21
  parameters: "(comparison_object)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 414
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 416
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1387
          def eql?(comparison_object)
            self == (comparison_object)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 415
  comment: "# Delegates to ==

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 124
  ra_comment_id: 415
  visibility: 1
  name: "eql?"
  ra_container_id: 21
  parameters: "(comparison_object)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 416
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 418
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1393
          def hash
            id.hash
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 417
  comment: >2
    # Delegates to id in order to allow two records of the same type and id to work
    with something like:

    #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1),
    Person.find(4) ] # => [ Person.find(1) ]

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 125
  ra_comment_id: 417
  visibility: 1
  name: hash
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 418
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 420
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1402
          def respond_to?(method, include_priv = false)
            if attr_name = self.class.column_methods_hash[method.to_sym]
              return true if @attributes.include?(attr_name) || attr_name == self.class.primary_key
              return false if self.class.read_methods.include?(attr_name)
            elsif @attributes.include?(method_name = method.to_s)
              return true
            elsif md = /(=|\?|_before_type_cast)$/.match(method_name)
              return true if @attributes.include?(md.pre_match)
            end
            # super must be called at the end of the method, because the inherited respond_to?
            # would return true for generated readers, even if the attribute wasn't present
            super
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 419
  comment: >2
    # A Person object with a name attribute can ask person.respond_to?("name"),
    person.respond_to?("name="), and

    # person.respond_to?("name?") which will all return true.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 126
  ra_comment_id: 419
  visibility: 1
  name: "respond_to?"
  ra_container_id: 21
  parameters: "(method, include_priv = false)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 420
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 422
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1417
          def freeze
            @attributes.freeze; self
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 421
  comment: "# Just freeze the attributes hash, such that associations are still accessible
even on destroyed records.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 127
  ra_comment_id: 421
  visibility: 1
  name: freeze
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 422
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 424
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1421
          def frozen?
            @attributes.frozen?
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 423
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 128
  ra_comment_id: 423
  visibility: 1
  name: "frozen?"
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 424
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 426
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1425
          def readonly?
            @readonly == true
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 425
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 129
  ra_comment_id: 425
  visibility: 1
  name: "readonly?"
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 426
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 428
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1429
          def readonly!
            @readonly = true
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 427
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 130
  ra_comment_id: 427
  visibility: 1
  name: readonly!
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 428
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 430
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1434
          def create_or_update
            if new_record? then create else update end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 429
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 131
  ra_comment_id: 429
  visibility: 2
  name: create_or_update
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 430
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 432
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1439
          def update
            connection.update(
              "UPDATE #{self.class.table_name} " +
              "SET #{quoted_comma_pair_list(connection, attributes_with_quotes(false))} " +
              "WHERE #{self.class.primary_key} = #{quote(id)}",
              "#{self.class.name} Update"
            )
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 431
  comment: "# Updates the associated record with values matching those of the instance
attributes.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 132
  ra_comment_id: 431
  visibility: 2
  name: update
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 432
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 434
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1449
          def create
            if self.id.nil? and connection.prefetch_primary_key?(self.class.table_name)
              self.id = connection.next_sequence_value(self.class.sequence_name)
            end

            self.id = connection.insert(
              "INSERT INTO #{self.class.table_name} " +
              "(#{quoted_column_names.join(', ')}) " +
              "VALUES(#{attributes_with_quotes.values.join(', ')})",
              "#{self.class.name} Create",
              self.class.primary_key, self.id, self.class.sequence_name
            )

            @new_record = false
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 433
  comment: "# Creates a new record with values matching those of the instance attributes.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 133
  ra_comment_id: 433
  visibility: 2
  name: create
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 434
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 436
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1469
          def ensure_proper_type
            unless self.class.descends_from_active_record?
              write_attribute(self.class.inheritance_column, Inflector.demodulize(self.class.name))
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 435
  comment: >2
    # Sets the attribute used for single table inheritance to this class name if
    this is not the ActiveRecord descendent.

    # Considering the hierarchy Reply < Message < ActiveRecord, this makes it
    possible to do Reply.new without having to

    # set Reply[Reply.inheritance_column] = "Reply" yourself. No such attribute
    would be set for objects of the

    # Message class in that example.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 134
  ra_comment_id: 435
  visibility: 2
  name: ensure_proper_type
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 436
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 438
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1483
          def method_missing(method_id, *args, &block)
            method_name = method_id.to_s
            if @attributes.include?(method_name)
              define_read_methods if self.class.read_methods.empty? && self.class.generate_read_methods
              read_attribute(method_name)
            elsif self.class.primary_key.to_s == method_name
              id
            elsif md = /(=|\?|_before_type_cast)$/.match(method_name)
              attribute_name, method_type = md.pre_match, md.to_s
              if @attributes.include?(attribute_name)
                case method_type
                  when '='
                    write_attribute(attribute_name, args.first)
                  when '?'
                    query_attribute(attribute_name)
                  when '_before_type_cast'
                    read_attribute_before_type_cast(attribute_name)
                end
              else
                super
              end
            else
              super
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 437
  comment: >2
    # Allows access to the object attributes, which are held in the @attributes
    hash, as were

    # they first-class methods. So a Person class with a name attribute can use
    Person#name and

    # Person#name= and never directly use the attributes hash -- except for multiple
    assigns with

    # ActiveRecord#attributes=. A Milestone class can also ask Milestone#completed?
    to test that

    # the completed attribute is not nil or 0.

    #

    # It's also possible to instantiate related objects, so a Client class belonging
    to the clients

    # table with a master_id foreign key can instantiate master through
    Client#master.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 135
  ra_comment_id: 437
  visibility: 2
  name: method_missing
  ra_container_id: 21
  parameters: "(method_id, *args, &block)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 438
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 440
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1511
          def read_attribute(attr_name)
            attr_name = attr_name.to_s
            if !(value = @attributes[attr_name]).nil?
              if column = column_for_attribute(attr_name)
                if unserializable_attribute?(attr_name, column)
                  unserialize_attribute(attr_name)
                else
                  column.type_cast(value)
                end
              else
                value
              end
            else
              nil
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 439
  comment: >2
    # Returns the value of the attribute identified by <tt>attr_name</tt> after it
    has been typecast (for example,

    # "2004-12-12" in a data column is cast to a date object, like Date.new(2004,
    12, 12)).

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 136
  ra_comment_id: 439
  visibility: 2
  name: read_attribute
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 440
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 442
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1528
          def read_attribute_before_type_cast(attr_name)
            @attributes[attr_name]
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 441
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 137
  ra_comment_id: 441
  visibility: 2
  name: read_attribute_before_type_cast
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 442
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 444
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1535
          def define_read_methods
            self.class.columns_hash.each do |name, column|
              unless self.class.serialized_attributes[name] || respond_to_without_attributes?(name)
                define_read_method(name.to_sym, name, column)
              end
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 443
  comment: >2
    # Called on first read access to any given column and generates reader

    # methods for all columns in the columns_hash if

    # ActiveRecord::Base.generate_read_methods is set to true.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 138
  ra_comment_id: 443
  visibility: 2
  name: define_read_methods
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 444
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 446
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1544
          def define_read_method(symbol, attr_name, column)
            cast_code = column.type_cast_code('v') if column
            access_code = cast_code ? "(v=@attributes['#{attr_name}']) && #{cast_code}" : "@attributes['#{attr_name}']"

            unless attr_name.to_s == self.class.primary_key.to_s
              access_code = access_code.insert(0, "raise NoMethodError, 'missing attribute: #{attr_name}', caller unless @attributes.has_key?('#{attr_name}'); ")
              self.class.read_methods << attr_name
            end

            begin
              self.class.class_eval("def #{symbol}; #{access_code}; end")
            rescue SyntaxError => err
              self.class.read_methods.delete(attr_name)
              if logger
                logger.warn "Exception occured during reader method compilation."
                logger.warn "Maybe #{attr_name} is not a valid Ruby identifier?"
                logger.warn "#{err.message}"
              end
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 445
  comment: "# Define an attribute reader method.  Cope with nil column.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 139
  ra_comment_id: 445
  visibility: 2
  name: define_read_method
  ra_container_id: 21
  parameters: "(symbol, attr_name, column)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 446
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 448
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1566
          def unserializable_attribute?(attr_name, column)
            column.text? && self.class.serialized_attributes[attr_name]
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 447
  comment: "# Returns true if the attribute is of a text column and marked for
serialization.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 140
  ra_comment_id: 447
  visibility: 2
  name: "unserializable_attribute?"
  ra_container_id: 21
  parameters: "(attr_name, column)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 448
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 450
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1571
          def unserialize_attribute(attr_name)
            unserialized_object = object_from_yaml(@attributes[attr_name])

            if unserialized_object.is_a?(self.class.serialized_attributes[attr_name])
              @attributes[attr_name] = unserialized_object
            else
              raise SerializationTypeMismatch,
                "#{attr_name} was supposed to be a #{self.class.serialized_attributes[attr_name]}, but was a #{unserialized_object.class.to_s}"
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 449
  comment: "# Returns the unserialized object of the attribute.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 141
  ra_comment_id: 449
  visibility: 2
  name: unserialize_attribute
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 450
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 452
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1584
          def write_attribute(attr_name, value)
            attr_name = attr_name.to_s
            if (column = column_for_attribute(attr_name)) && column.number?
              @attributes[attr_name] = convert_number_column_value(value)
            else
              @attributes[attr_name] = value
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 451
  comment: >2
    # Updates the attribute identified by <tt>attr_name</tt> with the specified
    +value+. Empty strings for fixnum and float

    # columns are turned into nil.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 142
  ra_comment_id: 451
  visibility: 2
  name: write_attribute
  ra_container_id: 21
  parameters: "(attr_name, value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 452
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 454
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1593
          def convert_number_column_value(value)
            case value
              when FalseClass: 0
              when TrueClass:  1
              when '':         nil
              else value
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 453
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 143
  ra_comment_id: 453
  visibility: 2
  name: convert_number_column_value
  ra_container_id: 21
  parameters: "(value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 454
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 456
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1602
          def query_attribute(attr_name)
            attribute = @attributes[attr_name]
            if attribute.kind_of?(Fixnum) && attribute == 0
              false
            elsif attribute.kind_of?(String) && attribute == "0"
              false
            elsif attribute.kind_of?(String) && attribute.empty?
              false
            elsif attribute.nil?
              false
            elsif attribute == false
              false
            elsif attribute == "f"
              false
            elsif attribute == "false"
              false
            else
              true
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 455
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 144
  ra_comment_id: 455
  visibility: 2
  name: query_attribute
  ra_container_id: 21
  parameters: "(attr_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 456
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 458
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1623
          def remove_attributes_protected_from_mass_assignment(attributes)
            if self.class.accessible_attributes.nil? && self.class.protected_attributes.nil?
              attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            elsif self.class.protected_attributes.nil?
              attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, "").intern) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            elsif self.class.accessible_attributes.nil?
              attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,"").intern) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 457
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 145
  ra_comment_id: 457
  visibility: 2
  name: remove_attributes_protected_from_mass_assignment
  ra_container_id: 21
  parameters: "(attributes)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 458
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 460
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1634
          def attributes_protected_by_default
            default = [ self.class.primary_key, self.class.inheritance_column ]
            default << 'id' unless self.class.primary_key.eql? 'id'
            default
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 459
  comment: "# The primary key and inheritance column can never be set by mass-assignment for
security reasons.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 146
  ra_comment_id: 459
  visibility: 2
  name: attributes_protected_by_default
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 460
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 462
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1642
          def attributes_with_quotes(include_primary_key = true)
            attributes.inject({}) do |quoted, (name, value)|
              if column = column_for_attribute(name)
                quoted[name] = quote(value, column) unless !include_primary_key && column.primary
              end
              quoted
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 461
  comment: >2
    # Returns copy of the attributes hash where all the values have been safely
    quoted for use in

    # an SQL statement.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 147
  ra_comment_id: 461
  visibility: 2
  name: attributes_with_quotes
  ra_container_id: 21
  parameters: "(include_primary_key = true)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 462
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 464
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1652
          def quote(value, column = nil)
            self.class.connection.quote(value, column)
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 463
  comment: "# Quote strings appropriately for SQL statements.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 148
  ra_comment_id: 463
  visibility: 2
  name: quote
  ra_container_id: 21
  parameters: "(value, column = nil)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 464
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 466
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1658
          def interpolate_sql(sql, record = nil)
            instance_eval("%@#{sql.gsub('@', '\@')}@")
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 465
  comment: >2
    # Interpolate custom sql string in instance context.

    # Optional record argument is meant for custom insert_sql.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 149
  ra_comment_id: 465
  visibility: 2
  name: interpolate_sql
  ra_container_id: 21
  parameters: "(sql, record = nil)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 466
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 468
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1666
          def attributes_from_column_definition
            self.class.columns.inject({}) do |attributes, column|
              attributes[column.name] = column.default unless column.name == self.class.primary_key
              attributes
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 467
  comment: >2
    # Initializes the attributes array with keys matching the columns from the
    linked table and

    # the values matching the corresponding default value of that column, so

    # that a new instance, or one populated from a passed-in Hash, still has all the
    attributes

    # that instances loaded from the database would.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 150
  ra_comment_id: 467
  visibility: 2
  name: attributes_from_column_definition
  ra_container_id: 21
  parameters: "()"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 468
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 470
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1679
          def assign_multiparameter_attributes(pairs)
            execute_callstack_for_multiparameter_attributes(
              extract_callstack_for_multiparameter_attributes(pairs)
            )
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 469
  comment: >2
    # Instantiates objects for all attribute classes that needs more than one
    constructor parameter. This is done

    # by calling new on the column type or aggregation type (through composed_of)
    object with these parameters.

    # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3)
    = "24", will instantiate

    # written_on (a date type) with Date.new("2004", "6", "24"). You can also
    specify a typecast character in the

    # parentheses to have the parameters typecasted before they're used in the
    constructor. Use i for Fixnum, f for Float,

    # s for String, and a for Array. If all the values for a given attribute is
    empty, the attribute will be set to nil.

new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 151
  ra_comment_id: 469
  visibility: 2
  name: assign_multiparameter_attributes
  ra_container_id: 21
  parameters: "(pairs)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 470
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 472
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1686
          def execute_callstack_for_multiparameter_attributes(callstack)
            errors = []
            callstack.each do |name, values|
              klass = (self.class.reflect_on_aggregation(name) || column_for_attribute(name)).klass
              if values.empty?
                send(name + "=", nil)
              else
                begin
                  send(name + "=", Time == klass ? klass.local(*values) : klass.new(*values))
                rescue => ex
                  errors << AttributeAssignmentError.new("error on assignment #{values.inspect} to #{name}", ex, name)
                end
              end
            end
            unless errors.empty?
              raise MultiparameterAssignmentErrors.new(errors), "#{errors.size} error(s) on assignment of multiparameter attributes"
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 471
  comment: "# Includes an ugly hack for Time.local instead of Time.new because the latter is
reserved by Time itself.

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 152
  ra_comment_id: 471
  visibility: 2
  name: execute_callstack_for_multiparameter_attributes
  ra_container_id: 21
  parameters: "(callstack)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 472
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 474
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1705
          def extract_callstack_for_multiparameter_attributes(pairs)
            attributes = { }

            for pair in pairs
              multiparameter_name, value = pair
              attribute_name = multiparameter_name.split("(").first
              attributes[attribute_name] = [] unless attributes.include?(attribute_name)

              unless value.empty?
                attributes[attribute_name] <<
                  [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]
              end
            end

            attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 473
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 153
  ra_comment_id: 473
  visibility: 2
  name: extract_callstack_for_multiparameter_attributes
  ra_container_id: 21
  parameters: "(pairs)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 474
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 476
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1722
          def type_cast_attribute_value(multiparameter_name, value)
            multiparameter_name =~ /\([0-9]*([a-z])\)/ ? value.send("to_" + $1) : value
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 475
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 154
  ra_comment_id: 475
  visibility: 2
  name: type_cast_attribute_value
  ra_container_id: 21
  parameters: "(multiparameter_name, value)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 476
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 478
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1726
          def find_parameter_position(multiparameter_name)
            multiparameter_name.scan(/\(([0-9]*).*\)/).first.first
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 477
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 155
  ra_comment_id: 477
  visibility: 2
  name: find_parameter_position
  ra_container_id: 21
  parameters: "(multiparameter_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 478
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 480
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1731
          def comma_pair_list(hash)
            hash.inject([]) { |list, pair| list << "#{pair.first} = #{pair.last}" }.join(", ")
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 479
  comment: "# Returns a comma-separated pair list, like \"key1 = val1, key2 = val2\".

"
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 156
  ra_comment_id: 479
  visibility: 2
  name: comma_pair_list
  ra_container_id: 21
  parameters: "(hash)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 480
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 482
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1735
          def quoted_column_names(attributes = attributes_with_quotes)
            attributes.keys.collect do |column_name|
              self.class.connection.quote_column_name(column_name)
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 481
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 157
  ra_comment_id: 481
  visibility: 2
  name: quoted_column_names
  ra_container_id: 21
  parameters: "(attributes = attributes_with_quotes)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 482
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 484
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1741
          def quote_columns(quoter, hash)
            hash.inject({}) do |quoted, (name, value)|
              quoted[quoter.quote_column_name(name)] = value
              quoted
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 483
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 158
  ra_comment_id: 483
  visibility: 2
  name: quote_columns
  ra_container_id: 21
  parameters: "(quoter, hash)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 484
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 486
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1748
          def quoted_comma_pair_list(quoter, hash)
            comma_pair_list(quote_columns(quoter, hash))
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 485
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 159
  ra_comment_id: 485
  visibility: 2
  name: quoted_comma_pair_list
  ra_container_id: 21
  parameters: "(quoter, hash)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 486
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 488
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1752
          def object_from_yaml(string)
            return string unless string.is_a?(String)
            YAML::load(string) rescue string
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 487
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 160
  ra_comment_id: 487
  visibility: 2
  name: object_from_yaml
  ra_container_id: 21
  parameters: "(string)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 488
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 490
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1757
          def clone_attributes(reader_method = :read_attribute, attributes = {})
            self.attribute_names.inject(attributes) do |attributes, name|
              attributes[name] = clone_attribute_value(reader_method, name)
              attributes
            end
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 489
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 161
  ra_comment_id: 489
  visibility: 2
  name: clone_attributes
  ra_container_id: 21
  parameters: "(reader_method = :read_attribute, attributes = {})"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 490
new_record: true


--- !ruby/object:RaSourceCode 
attributes: 
  id: 492
  source_code: |2-
    # File testdoc-0.0.1/base.rb, line 1764
          def clone_attribute_value(reader_method, attribute_name)
            value = send(reader_method, attribute_name)
            value.clone
          rescue TypeError, NoMethodError
            value
          end
new_record: true
--- !ruby/object:RaComment 
attributes: 
  id: 491
  comment: ''
new_record: true
--- !ruby/object:RaMethod 
attributes: 
  id: 162
  ra_comment_id: 491
  visibility: 2
  name: clone_attribute_value
  ra_container_id: 21
  parameters: "(reader_method, attribute_name)"
  singleton: 0
  force_documentation: 0
  block_parameters: 
  ra_source_code_id: 492
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 163
  name: set_table_name
  ra_container_id: 21
  type: RaAlias
  value: table_name=
  comment: ''
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 164
  name: set_primary_key
  ra_container_id: 21
  type: RaAlias
  value: primary_key=
  comment: ''
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 165
  name: set_inheritance_column
  ra_container_id: 21
  type: RaAlias
  value: inheritance_column=
  comment: ''
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 166
  name: set_sequence_name
  ra_container_id: 21
  type: RaAlias
  value: sequence_name=
  comment: ''
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 167
  name: sanitize_sql
  ra_container_id: 21
  type: RaAlias
  value: sanitize_conditions
  comment: ''
new_record: true	
--- !ruby/object:RaAlias 
attributes: 
  id: 168
  name: respond_to?
  ra_container_id: 21
  type: RaAlias
  value: respond_to_without_attributes?
  comment: "# For checking respond_to? without searching the attributes (which is faster).

"
new_record: true
--- !ruby/object:RaConstant 
attributes: 
  id: 169
  name: SOME_TEST_CONSTANT
  ra_container_id: 21
  type: RaConstant
  value: "\"blahlbah\""
  comment: 
new_record: true
--- !ruby/object:RaConstant 
attributes: 
  id: 170
  name: ANOTHER_TEST_CONSTANT
  ra_container_id: 21
  type: RaConstant
  value: "\"blah2\""
  comment: 
new_record: true
--- !ruby/object:RaRequire 
attributes: 
  id: 4
  name: yaml
  ra_container_id: 3
  type: RaRequire
  comment: 
new_record: true
--- !ruby/object:RaRequire 
attributes: 
  id: 5
  name: set
  ra_container_id: 3
  type: RaRequire
  comment: 
new_record: true
--- !ruby/object:RaRequire 
attributes: 
  id: 6
  name: active_record/deprecated_finders
  ra_container_id: 3
  type: RaRequire
  comment: 
new_record: true