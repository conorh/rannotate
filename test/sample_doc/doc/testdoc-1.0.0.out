--- !ruby/object:RaComment 
attributes: 
  id: 3
  comment: ""
new_record: true

--- !ruby/object:RaFile 
attributes: 
  ra_comment_id: 3
  name: testdoc-1.0.0/base.rb
  ra_library_id: 0
  type: RaFile
  id: 4
  parent_id: 0
  full_name: testdoc-1.0.0/base.rb
new_record: true

--- !ruby/object:RaRequire 
attributes: 
  name: yaml
  ra_container_id: 4
  type: RaRequire
  id: 5
  comment: 
new_record: true

--- !ruby/object:RaRequire 
attributes: 
  name: set
  ra_container_id: 4
  type: RaRequire
  id: 6
  comment: 
new_record: true

--- !ruby/object:RaRequire 
attributes: 
  name: active_record/deprecated_finders
  ra_container_id: 4
  type: RaRequire
  id: 7
  comment: 
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 8
  comment: ""
new_record: true

--- !ruby/object:RaModule 
attributes: 
  superclass: 
  ra_comment_id: 8
  name: ActiveRecord
  ra_library_id: 0
  type: RaModule
  id: 9
  parent_id: 4
  full_name: ActiveRecord
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 9
  file_name: testdoc-1.0.0/base.rb
  id: 10
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 11
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: StandardError
  ra_comment_id: 11
  name: ReadOnlyRecord
  ra_library_id: 0
  type: RaClass
  id: 12
  parent_id: 9
  full_name: ActiveRecord::ReadOnlyRecord
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 12
  file_name: testdoc-1.0.0/base.rb
  id: 13
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 14
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 14
  name: StatementInvalid
  ra_library_id: 0
  type: RaClass
  id: 15
  parent_id: 9
  full_name: ActiveRecord::StatementInvalid
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 15
  file_name: testdoc-1.0.0/base.rb
  id: 16
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 17
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 17
  name: AdapterNotSpecified
  ra_library_id: 0
  type: RaClass
  id: 18
  parent_id: 9
  full_name: ActiveRecord::AdapterNotSpecified
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 18
  file_name: testdoc-1.0.0/base.rb
  id: 19
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 20
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 20
  name: AttributeAssignmentError
  ra_library_id: 0
  type: RaClass
  id: 21
  parent_id: 9
  full_name: ActiveRecord::AttributeAssignmentError
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 21
  file_name: testdoc-1.0.0/base.rb
  id: 22
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 23
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 23
  name: AssociationTypeMismatch
  ra_library_id: 0
  type: RaClass
  id: 24
  parent_id: 9
  full_name: ActiveRecord::AssociationTypeMismatch
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 24
  file_name: testdoc-1.0.0/base.rb
  id: 25
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 26
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 26
  name: RecordNotFound
  ra_library_id: 0
  type: RaClass
  id: 27
  parent_id: 9
  full_name: ActiveRecord::RecordNotFound
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 27
  file_name: testdoc-1.0.0/base.rb
  id: 28
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 29
  comment: |
    # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with
    # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change
    # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain
    # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
    #
    # See the mapping rules in table_name and the full example in link:files/README.html for more insight.
    #
    # == Creation
    #
    # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when
    # you're receiving the data from somewhere else, like a HTTP request. It works like this:
    #
    #   user = User.new(:name => "David", :occupation => "Code Artist")
    #   user.name # => "David"
    #
    # You can also use block initialization:
    #
    #   user = User.new do |u|
    #     u.name = "David"
    #     u.occupation = "Code Artist"
    #   end
    #
    # And of course you can just create a bare object and specify the attributes after the fact:
    #
    #   user = User.new
    #   user.name = "David"
    #   user.occupation = "Code Artist"
    #
    # == Conditions
    #
    # Conditions can either be specified as a string or an array representing the WHERE-part of an SQL statement.
    # The array form is to be used when the condition input is tainted and requires sanitization. The string form can
    # be used for statements that don't involve tainted data. Examples:
    #
    #   User < ActiveRecord::Base
    #     def self.authenticate_unsafely(user_name, password)
    #       find(:first, :conditions => "user_name = '#{user_name}' AND password = '#{password}'")
    #     end
    #
    #     def self.authenticate_safely(user_name, password)
    #       find(:first, :conditions => [ "user_name = ? AND password = ?", user_name, password ])
    #     end
    #   end
    #
    # The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query and is thus susceptible to SQL-injection
    # attacks if the <tt>user_name</tt> and +password+ parameters come directly from a HTTP request. The <tt>authenticate_safely</tt> method,
    # on the other hand, will sanitize the <tt>user_name</tt> and +password+ before inserting them in the query, which will ensure that
    # an attacker can't escape the query and fake the login (or worse).
    #
    # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth
    # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing
    # the question marks with symbols and supplying a hash with values for the matching symbol keys:
    #
    #   Company.find(:first, [
    #     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",
    #     { :id => 3, :name => "37signals", :division => "First", :accounting_date => '2005-01-01' }
    #   ])
    #
    # == Overwriting default accessors
    #
    # All column values are automatically available through basic accessors on the Active Record object, but some times you
    # want to specialize this behavior. This can be done by either by overwriting the default accessors (using the same
    # name as the attribute) calling read_attribute(attr_name) and write_attribute(attr_name, value) to actually change things.
    # Example:
    #
    #   class Song < ActiveRecord::Base
    #     # Uses an integer of seconds to hold the length of the song
    #
    #     def length=(minutes)
    #       write_attribute(:length, minutes * 60)
    #     end
    #
    #     def length
    #       read_attribute(:length) / 60
    #     end
    #   end
    #
    # You can alternatively use self[:attribute]=(value) and self[:attribute] instead of write_attribute(:attribute, vaule) and
    # read_attribute(:attribute) as a shorter form.
    #
    # == Accessing attributes before they have been typecasted
    #
    # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.
    # That can be done by using the <attribute>_before_type_cast accessors that all attributes have. For example, if your Account model
    # has a balance attribute, you can call account.balance_before_type_cast or account.id_before_type_cast.
    #
    # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display
    # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you
    # want.
    #
    # == Dynamic attribute-based finders
    #
    # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by
    # appending the name of an attribute to <tt>find_by_</tt> or <tt>find_all_by_</tt>, so you get finders like Person.find_by_user_name,
    # Person.find_all_by_last_name, Payment.find_by_transaction_id. So instead of writing
    # <tt>Person.find(:first, ["user_name = ?", user_name])</tt>, you just do <tt>Person.find_by_user_name(user_name)</tt>.
    # And instead of writing <tt>Person.find(:all, ["last_name = ?", last_name])</tt>, you just do <tt>Person.find_all_by_last_name(last_name)</tt>.
    #
    # It's also possible to use multiple attributes in the same find by separating them with "_and_", so you get finders like
    # <tt>Person.find_by_user_name_and_password</tt> or even <tt>Payment.find_by_purchaser_and_state_and_country</tt>. So instead of writing
    # <tt>Person.find(:first, ["user_name = ? AND password = ?", user_name, password])</tt>, you just do
    # <tt>Person.find_by_user_name_and_password(user_name, password)</tt>.
    #
    # It's even possible to use all the additional parameters to find. For example, the full interface for Payment.find_all_by_amount
    # is actually Payment.find_all_by_amount(amount, options). And the full interface to Person.find_by_user_name is
    # actually Person.find_by_user_name(user_name, options). So you could call <tt>Payment.find_all_by_amount(50, :order => "created_on")</tt>.
    #
    # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with
    # <tt>find_or_create_by_</tt> and will return the object if it already exists and otherwise creates it, then returns it. Example:
    #
    #   # No 'Summer' tag exists
    #   Tag.find_or_create_by_name("Summer") # equal to Tag.create(:name => "Summer")
    #   
    #   # Now the 'Summer' tag does exist
    #   Tag.find_or_create_by_name("Summer") # equal to Tag.find_by_name("Summer")
    #
    # == Saving arrays, hashes, and other non-mappable objects in text columns
    #
    # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.
    # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:
    #
    #   class User < ActiveRecord::Base
    #     serialize :preferences
    #   end
    #
    #   user = User.create(:preferences) => { "background" => "black", "display" => large })
    #   User.find(user.id).preferences # => { "background" => "black", "display" => large }
    #
    # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a
    # descendent of a class not in the hierarchy. Example:
    #
    #   class User < ActiveRecord::Base
    #     serialize :preferences, Hash
    #   end
    #
    #   user = User.create(:preferences => %w( one two three ))
    #   User.find(user.id).preferences    # raises SerializationTypeMismatch
    #
    # == Single table inheritance
    #
    # Active Record allows inheritance by storing the name of the class in a column that by default is called "type" (can be changed
    # by overwriting <tt>Base.inheritance_column</tt>). This means that an inheritance looking like this:
    #
    #   class Company < ActiveRecord::Base; end
    #   class Firm < Company; end
    #   class Client < Company; end
    #   class PriorityClient < Client; end
    #
    # When you do Firm.create(:name => "37signals"), this record will be saved in the companies table with type = "Firm". You can then
    # fetch this row again using Company.find(:first, "name = '37signals'") and it will return a Firm object.
    #
    # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just
    # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.
    #
    # Note, all the attributes for all the cases are kept in the same table. Read more:
    # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
    #
    # == Connection to multiple databases in different models
    #
    # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.
    # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.
    # For example, if Course is a ActiveRecord::Base, but resides in a different database you can just say Course.establish_connection
    # and Course *and all its subclasses* will use this connection instead.
    #
    # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is
    # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.
    #
    # == Exceptions
    #
    # * +ActiveRecordError+ -- generic error class and superclass of all other errors raised by Active Record
    # * +AdapterNotSpecified+ -- the configuration hash used in <tt>establish_connection</tt> didn't include a
    #   <tt>:adapter</tt> key.
    # * +AdapterNotFound+ -- the <tt>:adapter</tt> key used in <tt>establish_connection</tt> specified an non-existent adapter
    #   (or a bad spelling of an existing one).
    # * +AssociationTypeMismatch+ -- the object assigned to the association wasn't of the type specified in the association definition.
    # * +SerializationTypeMismatch+ -- the object serialized wasn't of the class specified as the second parameter.
    # * +ConnectionNotEstablished+ -- no connection has been established. Use <tt>establish_connection</tt> before querying.
    # * +RecordNotFound+ -- no record responded to the find* method.
    #   Either the row with the given ID doesn't exist or the row didn't meet the additional restrictions.
    # * +StatementInvalid+ -- the database server rejected the SQL statement. The precise error is added in the  message.
    #   Either the record with the given ID doesn't exist or the record didn't meet the additional restrictions.
    # * +MultiparameterAssignmentErrors+ -- collection of errors that occurred during a mass assignment using the
    #   +attributes=+ method. The +errors+ property of this exception contains an array of +AttributeAssignmentError+
    #   objects that should be inspected to determine which attributes triggered the errors.
    # * +AttributeAssignmentError+ -- an error occurred while doing a mass assignment through the +attributes=+ method.
    #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.
    #
    # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
    # So it's possible to assign a logger to the class through Base.logger= which will then be used by all
    # instances in the current object space.

new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: Object
  ra_comment_id: 29
  name: Base
  ra_library_id: 0
  type: RaClass
  id: 30
  parent_id: 9
  full_name: ActiveRecord::Base
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 31
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 32
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 260
        def self.reset_subclasses
          nonreloadables = []
          subclasses.each do |klass|
            unless klass.reloadable?
              nonreloadables << klass
              next
            end
            klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }
            klass.instance_methods(false).each { |m| klass.send :undef_method, m }
          end
          @@subclasses = {}
          nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) << klass }
        end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reset_subclasses
  visibility: 1
  ra_comment_id: 31
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 33
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 32
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 34
  comment: |
    # Find operates with three different retrieval approaches:
    #
    # * Find by id: This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
    #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.
    # * Find first: This will return the first record matched by the options used. These options can either be specific
    #   conditions or merely an order. If no record can matched, nil is returned.
    # * Find all: This will return all the records matched by the options used. If no records are found, an empty array is returned.
    #
    # All approaches accept an option hash as their last parameter. The options are:
    #
    # * <tt>:conditions</tt>: An SQL fragment like "administrator = 1" or [ "user_name = ?", username ]. See conditions in the intro.
    # * <tt>:order</tt>: An SQL fragment like "created_at DESC, name".
    # * <tt>:group</tt>: An attribute name by which the result should be grouped. Uses the GROUP BY SQL-clause.
    # * <tt>:limit</tt>: An integer determining the limit on the number of rows that should be returned.
    # * <tt>:offset</tt>: An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
    # * <tt>:joins</tt>: An SQL fragment for additional joins like "LEFT JOIN comments ON comments.post_id = id". (Rarely needed).
    #   The records will be returned read-only since they will have attributes that do not correspond to the table's columns.
    #   Pass :readonly => false to override.
    # * <tt>:include</tt>: Names associations that should be loaded alongside using LEFT OUTER JOINs. The symbols named refer
    #   to already defined associations. See eager loading under Associations.
    # * <tt>:select</tt>: By default, this is * as in SELECT * FROM, but can be changed if you for example want to do a join, but not
    #   include the joined columns.
    # * <tt>:readonly</tt>: Mark the returned records read-only so they cannot be saved or updated.
    #
    # Examples for find by id:
    #   Person.find(1)       # returns the object for ID = 1
    #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
    #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
    #   Person.find([1])     # returns an array for objects the object with ID = 1
    #   Person.find(1, :conditions => "administrator = 1", :order => "created_on DESC")
    #
    # Examples for find first:
    #   Person.find(:first) # returns the first object fetched by SELECT * FROM people
    #   Person.find(:first, :conditions => [ "user_name = ?", user_name])
    #   Person.find(:first, :order => "created_on DESC", :offset => 5)
    #
    # Examples for find all:
    #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people
    #   Person.find(:all, :conditions => [ "category IN (?)", categories], :limit => 50)
    #   Person.find(:all, :offset => 10, :limit => 10)
    #   Person.find(:all, :include => [ :account, :friends ])
    #   Person.find(:all, :group => "category")

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 35
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 378
          def find(*args)
            options = extract_options_from_args!(args)
    
            # Inherit :readonly from finder scope if set.  Otherwise,
            # if :joins is not blank then :readonly defaults to true.
            unless options.has_key?(:readonly)
              if scoped?(:find, :readonly)
                options[:readonly] = scope(:find, :readonly)
              elsif !options[:joins].blank?
                options[:readonly] = true
              end
            end
    
            case args.first
              when :first
                find(:all, options.merge(options[:include] ? { } : { :limit => 1 })).first
              when :all
                records = options[:include] ? find_with_associations(options) : find_by_sql(construct_finder_sql(options))
                records.each { |record| record.readonly! } if options[:readonly]
                records
              else
                return args.first if args.first.kind_of?(Array) && args.first.empty?
                expects_array = args.first.kind_of?(Array)
                
                conditions = " AND (#{sanitize_sql(options[:conditions])})" if options[:conditions]
    
                ids = args.flatten.compact.uniq
                case ids.size
                  when 0
                    raise RecordNotFound, "Couldn't find #{name} without an ID#{conditions}"
                  when 1
                    if result = find(:first, options.merge({ :conditions => "#{table_name}.#{primary_key} = #{sanitize(ids.first)}#{conditions}" }))
                      return expects_array ? [ result ] : result
                    else
                      raise RecordNotFound, "Couldn't find #{name} with ID=#{ids.first}#{conditions}"
                    end
                  else
                    # Find multiple ids
                    ids_list = ids.map { |id| sanitize(id) }.join(',')
                    result   = find(:all, options.merge({ :conditions => "#{table_name}.#{primary_key} IN (#{ids_list})#{conditions}"}))
                    if result.size == ids.size
                      return result
                    else
                      raise RecordNotFound, "Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions}"
                    end
                end
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: find
  visibility: 1
  ra_comment_id: 34
  ra_container_id: 30
  parameters: (*args)
  singleton: 1
  id: 36
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 35
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 37
  comment: |
    # Works like find(:all), but requires a complete SQL string. Examples:
    #   Post.find_by_sql "SELECT p.*, c.author FROM posts p, comments c WHERE p.id = c.post_id"
    #   Post.find_by_sql ["SELECT * FROM posts WHERE author = ? AND created > ?", author_id, start_date]

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 38
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 430
          def find_by_sql(sql)
            connection.select_all(sanitize_sql(sql), "#{name} Load").collect! { |record| instantiate(record) }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: find_by_sql
  visibility: 1
  ra_comment_id: 37
  ra_container_id: 30
  parameters: (sql)
  singleton: 1
  id: 39
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 38
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 40
  comment: |
    # Returns true if the given +id+ represents the primary key of a record in the database, false otherwise.
    # Example:
    #   Person.exists?(5)

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 41
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 437
          def exists?(id)
            !find(:first, :conditions => ["#{primary_key} = ?", id]).nil? rescue false
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: exists?
  visibility: 1
  ra_comment_id: 40
  ra_container_id: 30
  parameters: (id)
  singleton: 1
  id: 42
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 41
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 43
  comment: |
    # Creates an object, instantly saves it as a record (if the validation permits it), and returns it. If the save
    # fails under validations, the unsaved object is still returned.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 44
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 443
          def create(attributes = nil)
            if attributes.is_a?(Array)
              attributes.collect { |attr| create(attr) }
            else
              attributes.reverse_merge!(scope(:create)) if scoped?(:create)
    
              object = new(attributes)
              object.save
              object
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: create
  visibility: 1
  ra_comment_id: 43
  ra_container_id: 30
  parameters: (attributes = nil)
  singleton: 1
  id: 45
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 44
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 46
  comment: |
    # Finds the record from the passed +id+, instantly saves it with the passed +attributes+ (if the validation permits it),
    # and returns it. If the save fails under validations, the unsaved object is still returned.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 47
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 457
          def update(id, attributes)
            if id.is_a?(Array)
              idx = -1
              id.collect { |id| idx += 1; update(id, attributes[idx]) }
            else
              object = find(id)
              object.update_attributes(attributes)
              object
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: update
  visibility: 1
  ra_comment_id: 46
  ra_container_id: 30
  parameters: (id, attributes)
  singleton: 1
  id: 48
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 47
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 49
  comment: |
    # Deletes the record with the given +id+ without instantiating an object first. If an array of ids is provided, all of them
    # are deleted.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 50
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 470
          def delete(id)
            delete_all([ "#{primary_key} IN (?)", id ])
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: delete
  visibility: 1
  ra_comment_id: 49
  ra_container_id: 30
  parameters: (id)
  singleton: 1
  id: 51
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 50
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 52
  comment: |
    # Destroys the record with the given +id+ by instantiating the object and calling #destroy (all the callbacks are the triggered).
    # If an array of ids is provided, all of them are destroyed.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 53
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 476
          def destroy(id)
            id.is_a?(Array) ? id.each { |id| destroy(id) } : find(id).destroy
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: destroy
  visibility: 1
  ra_comment_id: 52
  ra_container_id: 30
  parameters: (id)
  singleton: 1
  id: 54
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 53
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 55
  comment: |
    # Updates all records with the SET-part of an SQL update statement in +updates+ and returns an integer with the number of rows updated.
    # A subset of the records can be selected by specifying +conditions+. Example:
    #   Billing.update_all "category = 'authorized', approved = 1", "author = 'David'"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 56
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 483
          def update_all(updates, conditions = nil)
            sql  = "UPDATE #{table_name} SET #{sanitize_sql(updates)} "
            add_conditions!(sql, conditions)
            connection.update(sql, "#{name} Update")
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: update_all
  visibility: 1
  ra_comment_id: 55
  ra_container_id: 30
  parameters: (updates, conditions = nil)
  singleton: 1
  id: 57
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 56
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 58
  comment: |
    # Destroys the objects for all the records that match the +condition+ by instantiating each object and calling
    # the destroy method. Example:
    #   Person.destroy_all "last_login < '2004-04-04'"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 59
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 492
          def destroy_all(conditions = nil)
            find(:all, :conditions => conditions).each { |object| object.destroy }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: destroy_all
  visibility: 1
  ra_comment_id: 58
  ra_container_id: 30
  parameters: (conditions = nil)
  singleton: 1
  id: 60
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 59
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 61
  comment: |
    # Deletes all the records that match the +condition+ without instantiating the objects first (and hence not
    # calling the destroy method). Example:
    #   Post.delete_all "person_id = 5 AND (category = 'Something' OR category = 'Else')"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 62
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 499
          def delete_all(conditions = nil)
            sql = "DELETE FROM #{table_name} "
            add_conditions!(sql, conditions)
            connection.delete(sql, "#{name} Delete all")
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: delete_all
  visibility: 1
  ra_comment_id: 61
  ra_container_id: 30
  parameters: (conditions = nil)
  singleton: 1
  id: 63
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 62
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 64
  comment: |
    # Returns the number of records that meet the +conditions+. Zero is returned if no records match. Example:
    #   Product.count "sales > 1"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 65
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 507
          def count(conditions = nil, joins = nil)
            sql  = "SELECT COUNT(*) FROM #{table_name} "
            sql << " #{joins} " if joins
            add_conditions!(sql, conditions)
            count_by_sql(sql)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: count
  visibility: 1
  ra_comment_id: 64
  ra_container_id: 30
  parameters: (conditions = nil, joins = nil)
  singleton: 1
  id: 66
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 65
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 67
  comment: |
    # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
    #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 68
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 516
          def count_by_sql(sql)
            sql = sanitize_conditions(sql)
            connection.select_value(sql, "#{name} Count").to_i
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: count_by_sql
  visibility: 1
  ra_comment_id: 67
  ra_container_id: 30
  parameters: (sql)
  singleton: 1
  id: 69
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 68
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 70
  comment: |
    # Increments the specified counter by one. So <tt>DiscussionBoard.increment_counter("post_count",
    # discussion_board_id)</tt> would increment the "post_count" counter on the board responding to discussion_board_id.
    # This is used for caching aggregate values, so that they don't need to be computed every time. Especially important
    # for looping over a collection where each element require a number of aggregate values. Like the DiscussionBoard
    # that needs to list both the number of posts and comments.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 71
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 526
          def increment_counter(counter_name, id)
            update_all "#{counter_name} = #{counter_name} + 1", "#{primary_key} = #{quote(id)}"
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: increment_counter
  visibility: 1
  ra_comment_id: 70
  ra_container_id: 30
  parameters: (counter_name, id)
  singleton: 1
  id: 72
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 71
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 73
  comment: |
    # Works like increment_counter, but decrements instead.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 74
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 531
          def decrement_counter(counter_name, id)
            update_all "#{counter_name} = #{counter_name} - 1", "#{primary_key} = #{quote(id)}"
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: decrement_counter
  visibility: 1
  ra_comment_id: 73
  ra_container_id: 30
  parameters: (counter_name, id)
  singleton: 1
  id: 75
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 74
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 76
  comment: |
    # Attributes named in this macro are protected from mass-assignment, such as <tt>new(attributes)</tt> and
    # <tt>attributes=(attributes)</tt>. Their assignment will simply be ignored. Instead, you can use the direct writer
    # methods to do assignment. This is meant to protect sensitive attributes from being overwritten by URL/form hackers. Example:
    #
    #   class Customer < ActiveRecord::Base
    #     attr_protected :credit_rating
    #   end
    #
    #   customer = Customer.new("name" => David, "credit_rating" => "Excellent")
    #   customer.credit_rating # => nil
    #   customer.attributes = { "description" => "Jolly fellow", "credit_rating" => "Superb" }
    #   customer.credit_rating # => nil
    #
    #   customer.credit_rating = "Average"
    #   customer.credit_rating # => "Average"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 77
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 550
          def attr_protected(*attributes)
            write_inheritable_array("attr_protected", attributes - (protected_attributes || []))
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attr_protected
  visibility: 1
  ra_comment_id: 76
  ra_container_id: 30
  parameters: (*attributes)
  singleton: 1
  id: 78
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 77
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 79
  comment: |
    # If this macro is used, only those attributes named in it will be accessible for mass-assignment, such as
    # <tt>new(attributes)</tt> and <tt>attributes=(attributes)</tt>. This is the more conservative choice for mass-assignment
    # protection. If you'd rather start from an all-open default and restrict attributes as needed, have a look at
    # attr_protected.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 80
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 563
          def attr_accessible(*attributes)
            write_inheritable_array("attr_accessible", attributes - (accessible_attributes || []))
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attr_accessible
  visibility: 1
  ra_comment_id: 79
  ra_container_id: 30
  parameters: (*attributes)
  singleton: 1
  id: 81
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 80
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 82
  comment: |
    # Specifies that the attribute by the name of +attr_name+ should be serialized before saving to the database and unserialized
    # after loading from the database. The serialization is done through YAML. If +class_name+ is specified, the serialized
    # object must be of that class on retrieval or +SerializationTypeMismatch+ will be raised.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 83
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 575
          def serialize(attr_name, class_name = Object)
            serialized_attributes[attr_name.to_s] = class_name
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: serialize
  visibility: 1
  ra_comment_id: 82
  ra_container_id: 30
  parameters: (attr_name, class_name = Object)
  singleton: 1
  id: 84
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 83
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 85
  comment: |
    # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 86
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 580
          def serialized_attributes
            read_inheritable_attribute("attr_serialized") or write_inheritable_attribute("attr_serialized", {})
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: serialized_attributes
  visibility: 1
  ra_comment_id: 85
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 87
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 86
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 88
  comment: |
    # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending
    # directly from ActiveRecord. So if the hierarchy looks like: Reply < Message < ActiveRecord, then Message is used
    # to guess the table name from even when called on Reply. The rules used to do the guess are handled by the Inflector class
    # in Active Support, which knows almost all common English inflections (report a bug if your inflection isn't covered).
    #
    # Additionally, the class-level table_name_prefix is prepended to the table_name and the table_name_suffix is appended.
    # So if you have "myapp_" as a prefix, the table name guess for an Account class becomes "myapp_accounts".
    #
    # You can also overwrite this class method to allow for unguessable links, such as a Mouse class with a link to a
    # "mice" table. Example:
    #
    #   class Mouse < ActiveRecord::Base
    #      set_table_name "mice"
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 89
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 598
          def table_name
            reset_table_name
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: table_name
  visibility: 1
  ra_comment_id: 88
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 90
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 89
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 91
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 92
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 602
          def reset_table_name
            name = "#{table_name_prefix}#{undecorated_table_name(class_name_of_active_record_descendant(self))}#{table_name_suffix}"
            set_table_name name
            name
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reset_table_name
  visibility: 1
  ra_comment_id: 91
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 93
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 92
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 94
  comment: |
    # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the
    # primary_key_prefix_type setting, though.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 95
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 610
          def primary_key
            reset_primary_key
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: primary_key
  visibility: 1
  ra_comment_id: 94
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 96
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 95
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 97
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 98
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 614
          def reset_primary_key
            key = 'id'
            case primary_key_prefix_type
              when :table_name
                key = Inflector.foreign_key(class_name_of_active_record_descendant(self), false)
              when :table_name_with_underscore
                key = Inflector.foreign_key(class_name_of_active_record_descendant(self))
            end
            set_primary_key(key)
            key
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reset_primary_key
  visibility: 1
  ra_comment_id: 97
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 99
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 98
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 100
  comment: |
    # Defines the column name for use with single table inheritance -- can be overridden in subclasses.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 101
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 627
          def inheritance_column
            "type"
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: inheritance_column
  visibility: 1
  ra_comment_id: 100
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 102
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 101
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 103
  comment: |
    # Lazy-set the sequence name to the connection's default.  This method
    # is only ever called once since set_sequence_name overrides it.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 104
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 633
          def sequence_name
            reset_sequence_name
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: sequence_name
  visibility: 1
  ra_comment_id: 103
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 105
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 104
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 106
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 107
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 637
          def reset_sequence_name
            default = connection.default_sequence_name(table_name, primary_key)
            set_sequence_name(default)
            default
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reset_sequence_name
  visibility: 1
  ra_comment_id: 106
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 108
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 107
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 109
  comment: |
    # Sets the table name to use to the given value, or (if the value
    # is nil or false) to the value returned by the given block.
    #
    # Example:
    #
    #   class Project < ActiveRecord::Base
    #     set_table_name "project"
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 110
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 651
          def set_table_name( value=nil, &block )
            define_attr_method :table_name, value, &block
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: set_table_name
  visibility: 1
  ra_comment_id: 109
  ra_container_id: 30
  parameters: ( value=nil, &block )
  singleton: 1
  id: 111
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 110
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 112
  comment: |
    # Sets the name of the primary key column to use to the given value,
    # or (if the value is nil or false) to the value returned by the given
    # block.
    #
    # Example:
    #
    #   class Project < ActiveRecord::Base
    #     set_primary_key "sysid"
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 113
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 665
          def set_primary_key( value=nil, &block )
            define_attr_method :primary_key, value, &block
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: set_primary_key
  visibility: 1
  ra_comment_id: 112
  ra_container_id: 30
  parameters: ( value=nil, &block )
  singleton: 1
  id: 114
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 113
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 115
  comment: |
    # Sets the name of the inheritance column to use to the given value,
    # or (if the value # is nil or false) to the value returned by the
    # given block.
    #
    # Example:
    #
    #   class Project < ActiveRecord::Base
    #     set_inheritance_column do
    #       original_inheritance_column + "_id"
    #     end
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 116
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 681
          def set_inheritance_column( value=nil, &block )
            define_attr_method :inheritance_column, value, &block
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: set_inheritance_column
  visibility: 1
  ra_comment_id: 115
  ra_container_id: 30
  parameters: ( value=nil, &block )
  singleton: 1
  id: 117
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 116
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 118
  comment: |
    # Sets the name of the sequence to use when generating ids to the given
    # value, or (if the value is nil or false) to the value returned by the
    # given block. This is required for Oracle and is useful for any
    # database which relies on sequences for primary key generation.
    #
    # If a sequence name is not explicitly set when using Oracle or Firebird,
    # it will default to the commonly used pattern of: #{table_name}_seq
    #
    # If a sequence name is not explicitly set when using PostgreSQL, it
    # will discover the sequence corresponding to your primary key for you.
    #
    # Example:
    #
    #   class Project < ActiveRecord::Base
    #     set_sequence_name "projectseq"   # default would have been "project_seq"
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 119
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 702
          def set_sequence_name( value=nil, &block )
            define_attr_method :sequence_name, value, &block
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: set_sequence_name
  visibility: 1
  ra_comment_id: 118
  ra_container_id: 30
  parameters: ( value=nil, &block )
  singleton: 1
  id: 120
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 119
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 121
  comment: |
    # Indicates whether the table associated with this class exists

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 122
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 716
          def table_exists?
            if connection.respond_to?(:tables)
              connection.tables.include? table_name
            else
              # if the connection adapter hasn't implemented tables, there are two crude tests that can be
              # used - see if getting column info raises an error, or if the number of columns returned is zero
              begin
                reset_column_information
                columns.size > 0
              rescue ActiveRecord::StatementInvalid
                false
              end          
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: table_exists?
  visibility: 1
  ra_comment_id: 121
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 123
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 122
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 124
  comment: |
    # Returns an array of column objects for the table associated with this class.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 125
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 732
          def columns
            unless @columns
              @columns = connection.columns(table_name, "#{name} Columns")
              @columns.each {|column| column.primary = column.name == primary_key}
            end
            @columns
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: columns
  visibility: 1
  ra_comment_id: 124
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 126
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 125
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 127
  comment: |
    # Returns an array of column objects for the table associated with this class.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 128
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 741
          def columns_hash
            @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: columns_hash
  visibility: 1
  ra_comment_id: 127
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 129
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 128
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 130
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 131
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 745
          def column_names
            @column_names ||= columns.map { |column| column.name }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: column_names
  visibility: 1
  ra_comment_id: 130
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 132
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 131
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 133
  comment: |
    # Returns an array of column objects where the primary id, all columns ending in "_id" or "_count",
    # and columns used for single table inheritance have been removed.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 134
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 751
          def content_columns
            @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: content_columns
  visibility: 1
  ra_comment_id: 133
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 135
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 134
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 136
  comment: |
    # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key
    # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
    # is available.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 137
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 758
          def column_methods_hash
            @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
              attr_name = attr.to_s
              methods[attr.to_sym]       = attr_name
              methods["#{attr}=".to_sym] = attr_name
              methods["#{attr}?".to_sym] = attr_name
              methods["#{attr}_before_type_cast".to_sym] = attr_name
              methods
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: column_methods_hash
  visibility: 1
  ra_comment_id: 136
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 138
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 137
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 139
  comment: |
    # Contains the names of the generated reader methods.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 140
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 770
          def read_methods
            @read_methods ||= Set.new
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: read_methods
  visibility: 1
  ra_comment_id: 139
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 141
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 140
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 142
  comment: |
    # Resets all the cached information about columns, which will cause them to be reloaded on the next request.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 143
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 775
          def reset_column_information
            read_methods.each { |name| undef_method(name) }
            @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @read_methods = nil
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reset_column_information
  visibility: 1
  ra_comment_id: 142
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 144
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 143
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 145
  comment: |
    # Log and benchmark multiple statements in a single block. Example:
    #
    #   Project.benchmark("Creating project") do
    #     project = Project.create("name" => "stuff")
    #     project.create_manager("name" => "David")
    #     project.milestones << Milestone.find(:all)
    #   end
    #
    # The benchmark is only recorded if the current level of the logger matches the <tt>log_level</tt>, which makes it
    # easy to include benchmarking statements in production software that will remain inexpensive because the benchmark
    # will only be conducted if the log level is low enough.
    #
    # The logging of the multiple statements is turned off unless <tt>use_silence</tt> is set to false.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 146
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 817
          def benchmark(title, log_level = Logger::DEBUG, use_silence = true)
            if logger && logger.level == log_level
              result = nil
              seconds = Benchmark.realtime { result = use_silence ? silence { yield } : yield }
              logger.add(log_level, "#{title} (#{'%.5f' % seconds})")
              result
            else
              yield
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: benchmark
  visibility: 1
  ra_comment_id: 145
  ra_container_id: 30
  parameters: (title, log_level = Logger::DEBUG, use_silence = true)
  singleton: 1
  id: 147
  block_parameters: ""
  force_documentation: 0
  ra_source_code_id: 146
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 148
  comment: |
    # Silences the logger for the duration of the block.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 149
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 829
          def silence
            old_logger_level, logger.level = logger.level, Logger::ERROR if logger
            yield
          ensure
            logger.level = old_logger_level if logger
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: silence
  visibility: 1
  ra_comment_id: 148
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 150
  block_parameters: ""
  force_documentation: 0
  ra_source_code_id: 149
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 151
  comment: |
    # Scope parameters to method calls within the block.  Takes a hash of method_name => parameters hash.
    # method_name may be :find or :create.
    # :find parameters may include the <tt>:conditions</tt>, <tt>:joins</tt>,
    # <tt>:offset</tt>, <tt>:limit</tt>, and <tt>:readonly</tt> options.
    # :create parameters are an attributes hash.
    #
    #   Article.with_scope(:find => { :conditions => "blog_id = 1" }, :create => { :blog_id => 1 }) do
    #     Article.find(1) # => SELECT * from articles WHERE blog_id = 1 AND id = 1
    #     a = Article.create(1)
    #     a.blog_id == 1
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 152
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 847
          def with_scope(method_scoping = {})
            # Dup first and second level of hash (method and params).
            method_scoping = method_scoping.inject({}) do |hash, (method, params)|
              hash[method] = params.dup
              hash
            end
    
            method_scoping.assert_valid_keys [:find, :create]
            if f = method_scoping[:find]
              f.assert_valid_keys [:conditions, :joins, :offset, :limit, :readonly]
              f[:readonly] = true if !f[:joins].blank? && !f.has_key?(:readonly)
            end
    
            raise ArgumentError, "Nested scopes are not yet supported: #{scoped_methods.inspect}" unless scoped_methods.nil?
    
            self.scoped_methods = method_scoping
            yield
          ensure 
            self.scoped_methods = nil
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: with_scope
  visibility: 1
  ra_comment_id: 151
  ra_container_id: 30
  parameters: (method_scoping = {})
  singleton: 1
  id: 153
  block_parameters: ""
  force_documentation: 0
  ra_source_code_id: 152
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 154
  comment: |
    # Overwrite the default class equality method to provide support for association proxies.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 155
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 869
          def ===(object)
            object.is_a?(self)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: ===
  visibility: 1
  ra_comment_id: 154
  ra_container_id: 30
  parameters: (object)
  singleton: 1
  id: 156
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 155
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 157
  comment: |
    # Deprecated 

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 158
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 874
          def threaded_connections
            allow_concurrency
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: threaded_connections
  visibility: 1
  ra_comment_id: 157
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 159
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 158
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 160
  comment: |
    # Deprecated 

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 161
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 879
          def threaded_connections=(value)
            self.allow_concurrency = value
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: threaded_connections=
  visibility: 1
  ra_comment_id: 160
  ra_container_id: 30
  parameters: (value)
  singleton: 1
  id: 162
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 161
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 163
  comment: |
    # Finder methods must instantiate through this method to work with the single-table inheritance model
    # that makes it possible to create objects of different types from the same table.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 164
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 887
            def instantiate(record)
              object = 
                if subclass_name = record[inheritance_column]
                  if subclass_name.empty?
                    allocate
                  else
                    require_association_class(subclass_name)
                    begin
                      compute_type(subclass_name).allocate
                    rescue NameError
                      raise SubclassNotFound,
                        "The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. " +
                        "This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. " +
                        "Please rename this column if you didn't intend it to be used for storing the inheritance class " +
                        "or overwrite #{self.to_s}.inheritance_column to use another column for that information."
                    end
                  end
                else
                  allocate
                end
    
              object.instance_variable_set("@attributes", record)
              object
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: instantiate
  visibility: 2
  ra_comment_id: 163
  ra_container_id: 30
  parameters: (record)
  singleton: 1
  id: 165
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 164
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 166
  comment: |
    # Returns the name of the type of the record using the current module as a prefix. So descendents of
    # MyApp::Business::Account would appear as "MyApp::Business::AccountSubclass".

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 167
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 914
            def type_name_with_module(type_name)
              self.name =~ /::/ ? self.name.scan(/(.*)::/).first.first + "::" + type_name : type_name
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: type_name_with_module
  visibility: 2
  ra_comment_id: 166
  ra_container_id: 30
  parameters: (type_name)
  singleton: 1
  id: 168
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 167
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 169
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 170
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 918
            def construct_finder_sql(options)
              sql  = "SELECT #{options[:select] || '*'} FROM #{table_name} "
              add_joins!(sql, options)
              add_conditions!(sql, options[:conditions])
              sql << " GROUP BY #{options[:group]} " if options[:group]
              sql << " ORDER BY #{options[:order]} " if options[:order]
              add_limit!(sql, options)
              sql
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: construct_finder_sql
  visibility: 2
  ra_comment_id: 169
  ra_container_id: 30
  parameters: (options)
  singleton: 1
  id: 171
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 170
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 172
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 173
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 928
            def add_limit!(sql, options)
              options[:limit]  ||= scope(:find, :limit)
              options[:offset] ||= scope(:find, :offset)
              connection.add_limit_offset!(sql, options)
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: add_limit!
  visibility: 2
  ra_comment_id: 172
  ra_container_id: 30
  parameters: (sql, options)
  singleton: 1
  id: 174
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 173
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 175
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 176
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 934
            def add_joins!(sql, options)
              join = scope(:find, :joins) || options[:joins]
              sql << " #{join} " if join
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: add_joins!
  visibility: 2
  ra_comment_id: 175
  ra_container_id: 30
  parameters: (sql, options)
  singleton: 1
  id: 177
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 176
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 178
  comment: |
    # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 179
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 940
            def add_conditions!(sql, conditions)          
              segments = [scope(:find, :conditions)]
              segments << sanitize_sql(conditions) unless conditions.nil?
              segments << type_condition unless descends_from_active_record?        
              segments.compact!
              sql << "WHERE (#{segments.join(") AND (")}) " unless segments.empty?
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: add_conditions!
  visibility: 2
  ra_comment_id: 178
  ra_container_id: 30
  parameters: (sql, conditions)
  singleton: 1
  id: 180
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 179
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 181
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 182
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 948
            def type_condition
              quoted_inheritance_column = connection.quote_column_name(inheritance_column)
              type_condition = subclasses.inject("#{table_name}.#{quoted_inheritance_column} = '#{name.demodulize}' ") do |condition, subclass|
                condition << "OR #{table_name}.#{quoted_inheritance_column} = '#{subclass.name.demodulize}' "
              end
    
              " (#{type_condition}) "
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: type_condition
  visibility: 2
  ra_comment_id: 181
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 183
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 182
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 184
  comment: |
    # Guesses the table name, but does not decorate it with prefix and suffix information.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 185
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 958
            def undecorated_table_name(class_name = class_name_of_active_record_descendant(self))
              table_name = Inflector.underscore(Inflector.demodulize(class_name))
              table_name = Inflector.pluralize(table_name) if pluralize_table_names
              table_name
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: undecorated_table_name
  visibility: 2
  ra_comment_id: 184
  ra_container_id: 30
  parameters: (class_name = class_name_of_active_record_descendant(self))
  singleton: 1
  id: 186
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 185
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 187
  comment: |
    # Enables dynamic finders like find_by_user_name(user_name) and find_by_user_name_and_password(user_name, password) that are turned into
    # find(:first, :conditions => ["user_name = ?", user_name]) and  find(:first, :conditions => ["user_name = ? AND password = ?", user_name, password])
    # respectively. Also works for find(:all), but using find_all_by_amount(50) that are turned into find(:all, :conditions => ["amount = ?", 50]).
    #
    # It's even possible to use all the additional parameters to find. For example, the full interface for find_all_by_amount
    # is actually find_all_by_amount(amount, options).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 188
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 970
            def method_missing(method_id, *arguments)
              if match = /find_(all_by|by)_([_a-zA-Z]\w*)/.match(method_id.to_s)
                finder = determine_finder(match)
    
                attribute_names = extract_attribute_names_from_match(match)
                super unless all_attributes_exists?(attribute_names)
    
                conditions = construct_conditions_from_arguments(attribute_names, arguments)
    
                if arguments[attribute_names.length].is_a?(Hash)
                  find(finder, { :conditions => conditions }.update(arguments[attribute_names.length]))
                else
                  send("find_#{finder}", conditions, *arguments[attribute_names.length..-1]) # deprecated API
                end
              elsif match = /find_or_create_by_([_a-zA-Z]\w*)/.match(method_id.to_s)
                attribute_names = extract_attribute_names_from_match(match)
                super unless all_attributes_exists?(attribute_names)
    
                find(:first, :conditions => construct_conditions_from_arguments(attribute_names, arguments)) || 
                  create(construct_attributes_from_arguments(attribute_names, arguments))
              else
                super
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: method_missing
  visibility: 2
  ra_comment_id: 187
  ra_container_id: 30
  parameters: (method_id, *arguments)
  singleton: 1
  id: 189
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 188
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 190
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 191
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 995
            def determine_finder(match)
              match.captures.first == 'all_by' ? :all : :first
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: determine_finder
  visibility: 2
  ra_comment_id: 190
  ra_container_id: 30
  parameters: (match)
  singleton: 1
  id: 192
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 191
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 193
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 194
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 999
            def extract_attribute_names_from_match(match)
              match.captures.last.split('_and_')
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: extract_attribute_names_from_match
  visibility: 2
  ra_comment_id: 193
  ra_container_id: 30
  parameters: (match)
  singleton: 1
  id: 195
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 194
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 196
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 197
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1003
            def construct_conditions_from_arguments(attribute_names, arguments)
              conditions = []
              attribute_names.each_with_index { |name, idx| conditions << "#{table_name}.#{connection.quote_column_name(name)} #{attribute_condition(arguments[idx])} " }
              [ conditions.join(" AND "), *arguments[0...attribute_names.length] ]
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: construct_conditions_from_arguments
  visibility: 2
  ra_comment_id: 196
  ra_container_id: 30
  parameters: (attribute_names, arguments)
  singleton: 1
  id: 198
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 197
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 199
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 200
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1009
            def construct_attributes_from_arguments(attribute_names, arguments)
              attributes = {}
              attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }
              attributes
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: construct_attributes_from_arguments
  visibility: 2
  ra_comment_id: 199
  ra_container_id: 30
  parameters: (attribute_names, arguments)
  singleton: 1
  id: 201
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 200
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 202
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 203
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1015
            def all_attributes_exists?(attribute_names)
              attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: all_attributes_exists?
  visibility: 2
  ra_comment_id: 202
  ra_container_id: 30
  parameters: (attribute_names)
  singleton: 1
  id: 204
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 203
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 205
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 206
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1019
            def attribute_condition(argument)
              case argument
                when nil   then "IS ?"
                when Array then "IN (?)"
                else            "= ?"
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attribute_condition
  visibility: 2
  ra_comment_id: 205
  ra_container_id: 30
  parameters: (argument)
  singleton: 1
  id: 207
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 206
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 208
  comment: |
    # Defines an "attribute" method (like #inheritance_column or
    # #table_name). A new (class) method will be created with the
    # given name. If a value is specified, the new method will
    # return that value (as a string). Otherwise, the given block
    # will be used to compute the value of the method.
    #
    # The original method will be aliased, with the new name being
    # prefixed with "original_". This allows the new method to
    # access the original value.
    #
    # Example:
    #
    #   class A < ActiveRecord::Base
    #     define_attr_method :primary_key, "sysid"
    #     define_attr_method( :inheritance_column ) do
    #       original_inheritance_column + "_id"
    #     end
    #   end

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 209
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1045
            def define_attr_method(name, value=nil, &block)
              sing = class << self; self; end
              sing.send :alias_method, "original_#{name}", name
              if block_given?
                sing.send :define_method, name, &block
              else
                # use eval instead of a block to work around a memory leak in dev
                # mode in fcgi
                sing.class_eval "def #{name}; #{value.to_s.inspect}; end"
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: define_attr_method
  visibility: 2
  ra_comment_id: 208
  ra_container_id: 30
  parameters: (name, value=nil, &block)
  singleton: 1
  id: 210
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 209
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 211
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 212
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1058
            def subclasses
              @@subclasses[self] ||= []
              @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: subclasses
  visibility: 3
  ra_comment_id: 211
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 213
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 212
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 214
  comment: |
    # Test whether the given method and optional key are scoped.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 215
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1064
            def scoped?(method, key = nil)
              scoped_methods and scoped_methods.has_key?(method) and (key.nil? or scope(method).has_key?(key))
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: scoped?
  visibility: 3
  ra_comment_id: 214
  ra_container_id: 30
  parameters: (method, key = nil)
  singleton: 1
  id: 216
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 215
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 217
  comment: |
    # Retrieve the scope for the given method and optional key.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 218
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1069
            def scope(method, key = nil)
              if scoped_methods and scope = scoped_methods[method]
                key ? scope[key] : scope
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: scope
  visibility: 3
  ra_comment_id: 217
  ra_container_id: 30
  parameters: (method, key = nil)
  singleton: 1
  id: 219
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 218
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 220
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 221
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1075
            def scoped_methods
              if allow_concurrency
                Thread.current[:scoped_methods] ||= {}
                Thread.current[:scoped_methods][self] ||= nil
              else
                @scoped_methods ||= nil
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: scoped_methods
  visibility: 3
  ra_comment_id: 220
  ra_container_id: 30
  parameters: ()
  singleton: 1
  id: 222
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 221
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 223
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 224
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1084
            def scoped_methods=(value)
              if allow_concurrency
                Thread.current[:scoped_methods] ||= {}
                Thread.current[:scoped_methods][self] = value
              else
                @scoped_methods = value
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: scoped_methods=
  visibility: 3
  ra_comment_id: 223
  ra_container_id: 30
  parameters: (value)
  singleton: 1
  id: 225
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 224
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 226
  comment: |
    # Returns the class type of the record using the current module as a prefix. So descendents of
    # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 227
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1095
            def compute_type(type_name)
              type_name_with_module(type_name).split("::").inject(Object) do |final_type, part|
                final_type.const_get(part)
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: compute_type
  visibility: 3
  ra_comment_id: 226
  ra_container_id: 30
  parameters: (type_name)
  singleton: 1
  id: 228
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 227
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 229
  comment: |
    # Returns the name of the class descending directly from ActiveRecord in the inheritance hierarchy.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 230
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1102
            def class_name_of_active_record_descendant(klass)
              if klass.superclass == Base
                klass.name
              elsif klass.superclass.nil?
                raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
              else
                class_name_of_active_record_descendant(klass.superclass)
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: class_name_of_active_record_descendant
  visibility: 3
  ra_comment_id: 229
  ra_container_id: 30
  parameters: (klass)
  singleton: 1
  id: 231
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 230
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 232
  comment: |
    # Accepts an array or string.  The string is returned untouched, but the array has each value
    # sanitized and interpolated into the sql statement.
    #   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 233
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1115
            def sanitize_sql(ary)
              return ary unless ary.is_a?(Array)
    
              statement, *values = ary
              if values.first.is_a?(Hash) and statement =~ /:\w+/
                replace_named_bind_variables(statement, values.first)
              elsif statement.include?('?')
                replace_bind_variables(statement, values)
              else
                statement % values.collect { |value| connection.quote_string(value.to_s) }
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: sanitize_sql
  visibility: 3
  ra_comment_id: 232
  ra_container_id: 30
  parameters: (ary)
  singleton: 1
  id: 234
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 233
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 235
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 236
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1130
            def replace_bind_variables(statement, values)
              raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)
              bound = values.dup
              statement.gsub('?') { quote_bound_value(bound.shift) }
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: replace_bind_variables
  visibility: 3
  ra_comment_id: 235
  ra_container_id: 30
  parameters: (statement, values)
  singleton: 1
  id: 237
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 236
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 238
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 239
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1136
            def replace_named_bind_variables(statement, bind_vars)
              raise_if_bind_arity_mismatch(statement, statement.scan(/:(\w+)/).uniq.size, bind_vars.size)
              statement.gsub(/:(\w+)/) do
                match = $1.to_sym
                if bind_vars.include?(match)
                  quote_bound_value(bind_vars[match])
                else
                  raise PreparedStatementInvalid, "missing value for :#{match} in #{statement}"
                end
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: replace_named_bind_variables
  visibility: 3
  ra_comment_id: 238
  ra_container_id: 30
  parameters: (statement, bind_vars)
  singleton: 1
  id: 240
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 239
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 241
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 242
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1148
            def quote_bound_value(value)
              if (value.respond_to?(:map) && !value.is_a?(String))
                value.map { |v| connection.quote(v) }.join(',')
              else
                connection.quote(value)
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: quote_bound_value
  visibility: 3
  ra_comment_id: 241
  ra_container_id: 30
  parameters: (value)
  singleton: 1
  id: 243
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 242
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 244
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 245
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1156
            def raise_if_bind_arity_mismatch(statement, expected, provided)
              unless expected == provided
                raise PreparedStatementInvalid, "wrong number of bind variables (#{provided} for #{expected}) in: #{statement}"
              end
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: raise_if_bind_arity_mismatch
  visibility: 3
  ra_comment_id: 244
  ra_container_id: 30
  parameters: (statement, expected, provided)
  singleton: 1
  id: 246
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 245
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 247
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 248
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1162
            def extract_options_from_args!(args)
              options = args.last.is_a?(Hash) ? args.pop : {}
              validate_find_options(options)
              options
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: extract_options_from_args!
  visibility: 3
  ra_comment_id: 247
  ra_container_id: 30
  parameters: (args)
  singleton: 1
  id: 249
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 248
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 250
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 251
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1168
            def validate_find_options(options)
              options.assert_valid_keys [:conditions, :include, :joins, :limit, :offset, :order, :select, :readonly, :group]
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: validate_find_options
  visibility: 3
  ra_comment_id: 250
  ra_container_id: 30
  parameters: (options)
  singleton: 1
  id: 252
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 251
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 253
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 254
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1172
            def encode_quoted_value(value)
              quoted_value = connection.quote(value)
              quoted_value = "'#{quoted_value[1..-2].gsub(/\'/, "\\\\'")}'" if quoted_value.include?("\\\'") # (for ruby mode) " 
              quoted_value 
            end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: encode_quoted_value
  visibility: 3
  ra_comment_id: 253
  ra_container_id: 30
  parameters: (value)
  singleton: 1
  id: 255
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 254
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 256
  comment: |
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
    # attributes but not yet saved (pass a hash with key names matching the associated table column names).
    # In both instances, valid attribute keys are determined by the column names of the associated table --
    # hence you can't have attributes that aren't part of the table columns.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 257
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1184
          def initialize(attributes = nil)
            @attributes = attributes_from_column_definition
            @new_record = true
            ensure_proper_type
            self.attributes = attributes unless attributes.nil?
            yield self if block_given?
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: new
  visibility: 1
  ra_comment_id: 256
  ra_container_id: 30
  parameters: (attributes = nil)
  singleton: 1
  id: 258
  block_parameters: self if block_given?
  force_documentation: 0
  ra_source_code_id: 257
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 259
  comment: |
    # A model instance's primary key is always available as model.id
    # whether you name it the default 'id' or set it to something else.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 260
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1194
          def id
            attr_name = self.class.primary_key
            column = column_for_attribute(attr_name)
            define_read_method(:id, attr_name, column) if self.class.generate_read_methods
            read_attribute(attr_name)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: id
  visibility: 1
  ra_comment_id: 259
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 261
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 260
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 262
  comment: "Alias for #id"
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 263
  source_code: ""
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: to_param
  visibility: 1
  ra_comment_id: 262
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 264
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 263
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 265
  comment: |
    # Sets the primary ID.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 266
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1213
          def id=(value)
            write_attribute(self.class.primary_key, value)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: id=
  visibility: 1
  ra_comment_id: 265
  ra_container_id: 30
  parameters: (value)
  singleton: 0
  id: 267
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 266
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 268
  comment: |
    # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 269
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1218
          def new_record?
            @new_record
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: new_record?
  visibility: 1
  ra_comment_id: 268
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 270
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 269
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 271
  comment: |
    # * No record exists: Creates a new record with values matching those of the object attributes.
    # * A record does exist: Updates the record with values matching those of the object attributes.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 272
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1224
          def save
            raise ActiveRecord::ReadOnlyRecord if readonly?
            create_or_update
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: save
  visibility: 1
  ra_comment_id: 271
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 273
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 272
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 274
  comment: |
    # Deletes the record in the database and freezes this instance to reflect that no changes should
    # be made (since they can't be persisted).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 275
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1231
          def destroy
            unless new_record?
              connection.delete "DELETE FROM \#{self.class.table_name}\nWHERE \#{self.class.primary_key} = \#{quoted_id}\n", "#{self.class.name} Destroy"
            end
    
            freeze
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: destroy
  visibility: 1
  ra_comment_id: 274
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 276
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 275
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 277
  comment: |
    # Returns a clone of the record that hasn't been assigned an id yet and
    # is treated as a new record.  Note that this is a "shallow" clone:
    # it copies the object's attributes only, not its associations.
    # The extent of a "deep" clone is application-specific and is therefore
    # left to the application to implement according to its need.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 278
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1248
          def clone
            attrs = self.attributes_before_type_cast
            attrs.delete(self.class.primary_key)
            self.class.new do |record|
              record.send :instance_variable_set, '@attributes', attrs
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: clone
  visibility: 1
  ra_comment_id: 277
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 279
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 278
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 280
  comment: |
    # Updates a single attribute and saves the record. This is especially useful for boolean flags on existing records.
    # Note: This method is overwritten by the Validation module that'll make sure that updates made with this method
    # doesn't get subjected to validation checks. Hence, attributes can be updated even if the full object isn't valid.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 281
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1259
          def update_attribute(name, value)
            send(name.to_s + '=', value)
            save
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: update_attribute
  visibility: 1
  ra_comment_id: 280
  ra_container_id: 30
  parameters: (name, value)
  singleton: 0
  id: 282
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 281
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 283
  comment: |
    # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will
    # fail and false will be returned.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 284
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1266
          def update_attributes(attributes)
            self.attributes = attributes
            save
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: update_attributes
  visibility: 1
  ra_comment_id: 283
  ra_container_id: 30
  parameters: (attributes)
  singleton: 0
  id: 285
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 284
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 286
  comment: |
    # Initializes the +attribute+ to zero if nil and adds one. Only makes sense for number-based attributes. Returns self.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 287
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1272
          def increment(attribute)
            self[attribute] ||= 0
            self[attribute] += 1
            self
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: increment
  visibility: 1
  ra_comment_id: 286
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 288
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 287
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 289
  comment: |
    # Increments the +attribute+ and saves the record.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 290
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1279
          def increment!(attribute)
            increment(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: increment!
  visibility: 1
  ra_comment_id: 289
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 291
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 290
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 292
  comment: |
    # Initializes the +attribute+ to zero if nil and subtracts one. Only makes sense for number-based attributes. Returns self.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 293
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1284
          def decrement(attribute)
            self[attribute] ||= 0
            self[attribute] -= 1
            self
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: decrement
  visibility: 1
  ra_comment_id: 292
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 294
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 293
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 295
  comment: |
    # Decrements the +attribute+ and saves the record.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 296
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1291
          def decrement!(attribute)
            decrement(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: decrement!
  visibility: 1
  ra_comment_id: 295
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 297
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 296
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 298
  comment: |
    # Turns an +attribute+ that's currently true into false and vice versa. Returns self.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 299
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1296
          def toggle(attribute)
            self[attribute] = !send("#{attribute}?")
            self
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: toggle
  visibility: 1
  ra_comment_id: 298
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 300
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 299
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 301
  comment: |
    # Toggles the +attribute+ and saves the record.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 302
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1302
          def toggle!(attribute)
            toggle(attribute).update_attribute(attribute, self[attribute])
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: toggle!
  visibility: 1
  ra_comment_id: 301
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 303
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 302
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 304
  comment: |
    # Reloads the attributes of this object from the database.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 305
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1307
          def reload
            clear_aggregation_cache
            clear_association_cache
            @attributes.update(self.class.find(self.id).instance_variable_get('@attributes'))
            self
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: reload
  visibility: 1
  ra_comment_id: 304
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 306
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 305
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 307
  comment: |
    # Returns the value of the attribute identified by <tt>attr_name</tt> after it has been typecast (for example,
    # "2004-12-12" in a data column is cast to a date object, like Date.new(2004, 12, 12)).
    # (Alias for the protected read_attribute method).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 308
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1317
          def [](attr_name)
            read_attribute(attr_name)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: "[]"
  visibility: 1
  ra_comment_id: 307
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 309
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 308
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 310
  comment: |
    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected write_attribute method).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 311
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1323
          def []=(attr_name, value)
            write_attribute(attr_name, value)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: "[]="
  visibility: 1
  ra_comment_id: 310
  ra_container_id: 30
  parameters: (attr_name, value)
  singleton: 0
  id: 312
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 311
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 313
  comment: |
    # Allows you to set all the attributes at once by passing in a hash with keys
    # matching the attribute names (which again matches the column names). Sensitive attributes can be protected
    # from this form of mass-assignment by using the +attr_protected+ macro. Or you can alternatively
    # specify which attributes *can* be accessed in with the +attr_accessible+ macro. Then all the
    # attributes not included in that won't be allowed to be mass-assigned.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 314
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1332
          def attributes=(attributes)
            return if attributes.nil?
            attributes.stringify_keys!
    
            multi_parameter_attributes = []
            remove_attributes_protected_from_mass_assignment(attributes).each do |k, v|
              k.include?("(") ? multi_parameter_attributes << [ k, v ] : send(k + "=", v)
            end
            assign_multiparameter_attributes(multi_parameter_attributes)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes=
  visibility: 1
  ra_comment_id: 313
  ra_container_id: 30
  parameters: (attributes)
  singleton: 0
  id: 315
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 314
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 316
  comment: |
    # Returns a hash of all the attributes with their names as keys and clones of their objects as values.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 317
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1344
          def attributes
            clone_attributes :read_attribute
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes
  visibility: 1
  ra_comment_id: 316
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 318
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 317
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 319
  comment: |
    # Returns a hash of cloned attributes before typecasting and deserialization.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 320
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1349
          def attributes_before_type_cast
            clone_attributes :read_attribute_before_type_cast
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes_before_type_cast
  visibility: 1
  ra_comment_id: 319
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 321
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 320
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 322
  comment: |
    # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither
    # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 323
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1355
          def attribute_present?(attribute)
            value = read_attribute(attribute)
            !value.blank? or value == 0
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attribute_present?
  visibility: 1
  ra_comment_id: 322
  ra_container_id: 30
  parameters: (attribute)
  singleton: 0
  id: 324
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 323
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 325
  comment: |
    # Returns true if the given attribute is in the attributes hash

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 326
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1361
          def has_attribute?(attr_name)
            @attributes.has_key?(attr_name.to_s)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: has_attribute?
  visibility: 1
  ra_comment_id: 325
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 327
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 326
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 328
  comment: |
    # Returns an array of names for the attributes available on this object sorted alphabetically.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 329
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1366
          def attribute_names
            @attributes.keys.sort
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attribute_names
  visibility: 1
  ra_comment_id: 328
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 330
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 329
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 331
  comment: |
    # Returns the column object for the named attribute.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 332
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1371
          def column_for_attribute(name)
            self.class.columns_hash[name.to_s]
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: column_for_attribute
  visibility: 1
  ra_comment_id: 331
  ra_container_id: 30
  parameters: (name)
  singleton: 0
  id: 333
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 332
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 334
  comment: |
    # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 335
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1376
          def ==(comparison_object)
            comparison_object.equal?(self) ||
              (comparison_object.instance_of?(self.class) && 
                comparison_object.id == id && 
                !comparison_object.new_record?)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: ==
  visibility: 1
  ra_comment_id: 334
  ra_container_id: 30
  parameters: (comparison_object)
  singleton: 0
  id: 336
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 335
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 337
  comment: |
    # Delegates to ==

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 338
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1384
          def eql?(comparison_object)
            self == (comparison_object)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: eql?
  visibility: 1
  ra_comment_id: 337
  ra_container_id: 30
  parameters: (comparison_object)
  singleton: 0
  id: 339
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 338
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 340
  comment: |
    # Delegates to id in order to allow two records of the same type and id to work with something like:
    #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 341
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1390
          def hash
            id.hash
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: hash
  visibility: 1
  ra_comment_id: 340
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 342
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 341
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 343
  comment: |
    # A Person object with a name attribute can ask person.respond_to?("name"), person.respond_to?("name="), and
    # person.respond_to?("name?") which will all return true.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 344
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1399
          def respond_to?(method, include_priv = false)
            if attr_name = self.class.column_methods_hash[method.to_sym]
              return true if @attributes.include?(attr_name) || attr_name == self.class.primary_key
              return false if self.class.read_methods.include?(attr_name)
            elsif @attributes.include?(method_name = method.to_s)
              return true
            elsif md = /(=|\?|_before_type_cast)$/.match(method_name)
              return true if @attributes.include?(md.pre_match)
            end
            # super must be called at the end of the method, because the inherited respond_to?
            # would return true for generated readers, even if the attribute wasn't present
            super
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: respond_to?
  visibility: 1
  ra_comment_id: 343
  ra_container_id: 30
  parameters: (method, include_priv = false)
  singleton: 0
  id: 345
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 344
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 346
  comment: |
    # Just freeze the attributes hash, such that associations are still accessible even on destroyed records.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 347
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1414
          def freeze
            @attributes.freeze; self
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: freeze
  visibility: 1
  ra_comment_id: 346
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 348
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 347
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 349
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 350
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1418
          def frozen?
            @attributes.frozen?
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: frozen?
  visibility: 1
  ra_comment_id: 349
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 351
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 350
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 352
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 353
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1422
          def readonly?
            @readonly == true
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: readonly?
  visibility: 1
  ra_comment_id: 352
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 354
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 353
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 355
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 356
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1426
          def readonly!
            @readonly = true
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: readonly!
  visibility: 1
  ra_comment_id: 355
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 357
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 356
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 358
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 359
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1431
          def create_or_update
            if new_record? then create else update end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: create_or_update
  visibility: 2
  ra_comment_id: 358
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 360
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 359
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 361
  comment: |
    # Updates the associated record with values matching those of the instance attributes.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 362
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1436
          def update
            connection.update(
              "UPDATE #{self.class.table_name} " +
              "SET #{quoted_comma_pair_list(connection, attributes_with_quotes(false))} " +
              "WHERE #{self.class.primary_key} = #{quote(id)}",
              "#{self.class.name} Update"
            )
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: update
  visibility: 2
  ra_comment_id: 361
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 363
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 362
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 364
  comment: |
    # Creates a new record with values matching those of the instance attributes.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 365
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1446
          def create
            if self.id.nil? and connection.prefetch_primary_key?(self.class.table_name)
              self.id = connection.next_sequence_value(self.class.sequence_name)
            end
    
            self.id = connection.insert(
              "INSERT INTO #{self.class.table_name} " +
              "(#{quoted_column_names.join(', ')}) " +
              "VALUES(#{attributes_with_quotes.values.join(', ')})",
              "#{self.class.name} Create",
              self.class.primary_key, self.id, self.class.sequence_name
            )
    
            @new_record = false
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: create
  visibility: 2
  ra_comment_id: 364
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 366
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 365
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 367
  comment: |
    # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord descendent.
    # Considering the hierarchy Reply < Message < ActiveRecord, this makes it possible to do Reply.new without having to
    # set Reply[Reply.inheritance_column] = "Reply" yourself. No such attribute would be set for objects of the
    # Message class in that example.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 368
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1466
          def ensure_proper_type
            unless self.class.descends_from_active_record?
              write_attribute(self.class.inheritance_column, Inflector.demodulize(self.class.name))
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: ensure_proper_type
  visibility: 2
  ra_comment_id: 367
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 369
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 368
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 370
  comment: |
    # Allows access to the object attributes, which are held in the @attributes hash, as were
    # they first-class methods. So a Person class with a name attribute can use Person#name and
    # Person#name= and never directly use the attributes hash -- except for multiple assigns with
    # ActiveRecord#attributes=. A Milestone class can also ask Milestone#completed? to test that
    # the completed attribute is not nil or 0.
    #
    # It's also possible to instantiate related objects, so a Client class belonging to the clients
    # table with a master_id foreign key can instantiate master through Client#master.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 371
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1480
          def method_missing(method_id, *args, &block)
            method_name = method_id.to_s
            if @attributes.include?(method_name)
              define_read_methods if self.class.read_methods.empty? && self.class.generate_read_methods
              read_attribute(method_name)
            elsif self.class.primary_key.to_s == method_name
              id
            elsif md = /(=|\?|_before_type_cast)$/.match(method_name)
              attribute_name, method_type = md.pre_match, md.to_s
              if @attributes.include?(attribute_name)
                case method_type
                  when '='
                    write_attribute(attribute_name, args.first)
                  when '?'
                    query_attribute(attribute_name)
                  when '_before_type_cast'
                    read_attribute_before_type_cast(attribute_name)
                end
              else
                super
              end
            else
              super
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: method_missing
  visibility: 2
  ra_comment_id: 370
  ra_container_id: 30
  parameters: (method_id, *args, &block)
  singleton: 0
  id: 372
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 371
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 373
  comment: |
    # Returns the value of the attribute identified by <tt>attr_name</tt> after it has been typecast (for example,
    # "2004-12-12" in a data column is cast to a date object, like Date.new(2004, 12, 12)).

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 374
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1508
          def read_attribute(attr_name)
            attr_name = attr_name.to_s
            if !(value = @attributes[attr_name]).nil?
              if column = column_for_attribute(attr_name)
                if unserializable_attribute?(attr_name, column)
                  unserialize_attribute(attr_name)
                else
                  column.type_cast(value)
                end
              else
                value
              end
            else
              nil
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: read_attribute
  visibility: 2
  ra_comment_id: 373
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 375
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 374
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 376
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 377
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1525
          def read_attribute_before_type_cast(attr_name)
            @attributes[attr_name]
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: read_attribute_before_type_cast
  visibility: 2
  ra_comment_id: 376
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 378
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 377
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 379
  comment: |
    # Called on first read access to any given column and generates reader
    # methods for all columns in the columns_hash if
    # ActiveRecord::Base.generate_read_methods is set to true.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 380
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1532
          def define_read_methods
            self.class.columns_hash.each do |name, column|
              unless self.class.serialized_attributes[name] || respond_to_without_attributes?(name)
                define_read_method(name.to_sym, name, column)
              end
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: define_read_methods
  visibility: 2
  ra_comment_id: 379
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 381
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 380
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 382
  comment: |
    # Define an attribute reader method.  Cope with nil column.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 383
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1541
          def define_read_method(symbol, attr_name, column)
            cast_code = column.type_cast_code('v') if column
            access_code = cast_code ? "(v=@attributes['#{attr_name}']) && #{cast_code}" : "@attributes['#{attr_name}']"
    
            unless attr_name.to_s == self.class.primary_key.to_s
              access_code = access_code.insert(0, "raise NoMethodError, 'missing attribute: #{attr_name}', caller unless @attributes.has_key?('#{attr_name}'); ")
              self.class.read_methods << attr_name
            end
    
            begin
              self.class.class_eval("def #{symbol}; #{access_code}; end")
            rescue SyntaxError => err
              self.class.read_methods.delete(attr_name)
              if logger
                logger.warn "Exception occured during reader method compilation."
                logger.warn "Maybe #{attr_name} is not a valid Ruby identifier?"
                logger.warn "#{err.message}"
              end
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: define_read_method
  visibility: 2
  ra_comment_id: 382
  ra_container_id: 30
  parameters: (symbol, attr_name, column)
  singleton: 0
  id: 384
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 383
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 385
  comment: |
    # Returns true if the attribute is of a text column and marked for serialization.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 386
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1563
          def unserializable_attribute?(attr_name, column)
            column.text? && self.class.serialized_attributes[attr_name]
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: unserializable_attribute?
  visibility: 2
  ra_comment_id: 385
  ra_container_id: 30
  parameters: (attr_name, column)
  singleton: 0
  id: 387
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 386
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 388
  comment: |
    # Returns the unserialized object of the attribute.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 389
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1568
          def unserialize_attribute(attr_name)
            unserialized_object = object_from_yaml(@attributes[attr_name])
    
            if unserialized_object.is_a?(self.class.serialized_attributes[attr_name])
              @attributes[attr_name] = unserialized_object
            else
              raise SerializationTypeMismatch,
                "#{attr_name} was supposed to be a #{self.class.serialized_attributes[attr_name]}, but was a #{unserialized_object.class.to_s}"
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: unserialize_attribute
  visibility: 2
  ra_comment_id: 388
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 390
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 389
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 391
  comment: |
    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+. Empty strings for fixnum and float
    # columns are turned into nil.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 392
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1581
          def write_attribute(attr_name, value)
            attr_name = attr_name.to_s
            if (column = column_for_attribute(attr_name)) && column.number?
              @attributes[attr_name] = convert_number_column_value(value)
            else
              @attributes[attr_name] = value
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: write_attribute
  visibility: 2
  ra_comment_id: 391
  ra_container_id: 30
  parameters: (attr_name, value)
  singleton: 0
  id: 393
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 392
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 394
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 395
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1590
          def convert_number_column_value(value)
            case value
              when FalseClass: 0
              when TrueClass:  1
              when '':         nil
              else value
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: convert_number_column_value
  visibility: 2
  ra_comment_id: 394
  ra_container_id: 30
  parameters: (value)
  singleton: 0
  id: 396
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 395
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 397
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 398
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1599
          def query_attribute(attr_name)
            attribute = @attributes[attr_name]
            if attribute.kind_of?(Fixnum) && attribute == 0
              false
            elsif attribute.kind_of?(String) && attribute == "0"
              false
            elsif attribute.kind_of?(String) && attribute.empty?
              false
            elsif attribute.nil?
              false
            elsif attribute == false
              false
            elsif attribute == "f"
              false
            elsif attribute == "false"
              false
            else
              true
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: query_attribute
  visibility: 2
  ra_comment_id: 397
  ra_container_id: 30
  parameters: (attr_name)
  singleton: 0
  id: 399
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 398
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 400
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 401
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1620
          def remove_attributes_protected_from_mass_assignment(attributes)
            if self.class.accessible_attributes.nil? && self.class.protected_attributes.nil?
              attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            elsif self.class.protected_attributes.nil?
              attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, "").intern) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            elsif self.class.accessible_attributes.nil?
              attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,"").intern) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: remove_attributes_protected_from_mass_assignment
  visibility: 2
  ra_comment_id: 400
  ra_container_id: 30
  parameters: (attributes)
  singleton: 0
  id: 402
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 401
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 403
  comment: |
    # The primary key and inheritance column can never be set by mass-assignment for security reasons.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 404
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1631
          def attributes_protected_by_default
            default = [ self.class.primary_key, self.class.inheritance_column ]
            default << 'id' unless self.class.primary_key.eql? 'id'
            default
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes_protected_by_default
  visibility: 2
  ra_comment_id: 403
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 405
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 404
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 406
  comment: |
    # Returns copy of the attributes hash where all the values have been safely quoted for use in
    # an SQL statement.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 407
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1639
          def attributes_with_quotes(include_primary_key = true)
            attributes.inject({}) do |quoted, (name, value)|
              if column = column_for_attribute(name)
                quoted[name] = quote(value, column) unless !include_primary_key && column.primary
              end
              quoted
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes_with_quotes
  visibility: 2
  ra_comment_id: 406
  ra_container_id: 30
  parameters: (include_primary_key = true)
  singleton: 0
  id: 408
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 407
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 409
  comment: |
    # Quote strings appropriately for SQL statements.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 410
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1649
          def quote(value, column = nil)
            self.class.connection.quote(value, column)
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: quote
  visibility: 2
  ra_comment_id: 409
  ra_container_id: 30
  parameters: (value, column = nil)
  singleton: 0
  id: 411
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 410
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 412
  comment: |
    # Interpolate custom sql string in instance context.
    # Optional record argument is meant for custom insert_sql.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 413
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1655
          def interpolate_sql(sql, record = nil)
            instance_eval("%@#{sql.gsub('@', '\@')}@")
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: interpolate_sql
  visibility: 2
  ra_comment_id: 412
  ra_container_id: 30
  parameters: (sql, record = nil)
  singleton: 0
  id: 414
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 413
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 415
  comment: |
    # Initializes the attributes array with keys matching the columns from the linked table and
    # the values matching the corresponding default value of that column, so
    # that a new instance, or one populated from a passed-in Hash, still has all the attributes
    # that instances loaded from the database would.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 416
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1663
          def attributes_from_column_definition
            self.class.columns.inject({}) do |attributes, column|
              attributes[column.name] = column.default unless column.name == self.class.primary_key
              attributes
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: attributes_from_column_definition
  visibility: 2
  ra_comment_id: 415
  ra_container_id: 30
  parameters: ()
  singleton: 0
  id: 417
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 416
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 418
  comment: |
    # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
    # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
    # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate
    # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the
    # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,
    # s for String, and a for Array. If all the values for a given attribute is empty, the attribute will be set to nil.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 419
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1676
          def assign_multiparameter_attributes(pairs)
            execute_callstack_for_multiparameter_attributes(
              extract_callstack_for_multiparameter_attributes(pairs)
            )
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: assign_multiparameter_attributes
  visibility: 2
  ra_comment_id: 418
  ra_container_id: 30
  parameters: (pairs)
  singleton: 0
  id: 420
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 419
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 421
  comment: |
    # Includes an ugly hack for Time.local instead of Time.new because the latter is reserved by Time itself.

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 422
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1683
          def execute_callstack_for_multiparameter_attributes(callstack)
            errors = []
            callstack.each do |name, values|
              klass = (self.class.reflect_on_aggregation(name) || column_for_attribute(name)).klass
              if values.empty?
                send(name + "=", nil)
              else
                begin
                  send(name + "=", Time == klass ? klass.local(*values) : klass.new(*values))
                rescue => ex
                  errors << AttributeAssignmentError.new("error on assignment #{values.inspect} to #{name}", ex, name)
                end
              end
            end
            unless errors.empty?
              raise MultiparameterAssignmentErrors.new(errors), "#{errors.size} error(s) on assignment of multiparameter attributes"
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: execute_callstack_for_multiparameter_attributes
  visibility: 2
  ra_comment_id: 421
  ra_container_id: 30
  parameters: (callstack)
  singleton: 0
  id: 423
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 422
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 424
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 425
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1702
          def extract_callstack_for_multiparameter_attributes(pairs)
            attributes = { }
    
            for pair in pairs
              multiparameter_name, value = pair
              attribute_name = multiparameter_name.split("(").first
              attributes[attribute_name] = [] unless attributes.include?(attribute_name)
    
              unless value.empty?
                attributes[attribute_name] <<
                  [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]
              end
            end
    
            attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: extract_callstack_for_multiparameter_attributes
  visibility: 2
  ra_comment_id: 424
  ra_container_id: 30
  parameters: (pairs)
  singleton: 0
  id: 426
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 425
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 427
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 428
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1719
          def type_cast_attribute_value(multiparameter_name, value)
            multiparameter_name =~ /\([0-9]*([a-z])\)/ ? value.send("to_" + $1) : value
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: type_cast_attribute_value
  visibility: 2
  ra_comment_id: 427
  ra_container_id: 30
  parameters: (multiparameter_name, value)
  singleton: 0
  id: 429
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 428
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 430
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 431
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1723
          def find_parameter_position(multiparameter_name)
            multiparameter_name.scan(/\(([0-9]*).*\)/).first.first
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: find_parameter_position
  visibility: 2
  ra_comment_id: 430
  ra_container_id: 30
  parameters: (multiparameter_name)
  singleton: 0
  id: 432
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 431
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 433
  comment: |
    # Returns a comma-separated pair list, like "key1 = val1, key2 = val2".

new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 434
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1728
          def comma_pair_list(hash)
            hash.inject([]) { |list, pair| list << "#{pair.first} = #{pair.last}" }.join(", ")
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: comma_pair_list
  visibility: 2
  ra_comment_id: 433
  ra_container_id: 30
  parameters: (hash)
  singleton: 0
  id: 435
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 434
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 436
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 437
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1732
          def quoted_column_names(attributes = attributes_with_quotes)
            attributes.keys.collect do |column_name|
              self.class.connection.quote_column_name(column_name)
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: quoted_column_names
  visibility: 2
  ra_comment_id: 436
  ra_container_id: 30
  parameters: (attributes = attributes_with_quotes)
  singleton: 0
  id: 438
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 437
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 439
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 440
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1738
          def quote_columns(quoter, hash)
            hash.inject({}) do |quoted, (name, value)|
              quoted[quoter.quote_column_name(name)] = value
              quoted
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: quote_columns
  visibility: 2
  ra_comment_id: 439
  ra_container_id: 30
  parameters: (quoter, hash)
  singleton: 0
  id: 441
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 440
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 442
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 443
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1745
          def quoted_comma_pair_list(quoter, hash)
            comma_pair_list(quote_columns(quoter, hash))
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: quoted_comma_pair_list
  visibility: 2
  ra_comment_id: 442
  ra_container_id: 30
  parameters: (quoter, hash)
  singleton: 0
  id: 444
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 443
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 445
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 446
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1749
          def object_from_yaml(string)
            return string unless string.is_a?(String)
            YAML::load(string) rescue string
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: object_from_yaml
  visibility: 2
  ra_comment_id: 445
  ra_container_id: 30
  parameters: (string)
  singleton: 0
  id: 447
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 446
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 448
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 449
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1754
          def clone_attributes(reader_method = :read_attribute, attributes = {})
            self.attribute_names.inject(attributes) do |attributes, name|
              attributes[name] = clone_attribute_value(reader_method, name)
              attributes
            end
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: clone_attributes
  visibility: 2
  ra_comment_id: 448
  ra_container_id: 30
  parameters: (reader_method = :read_attribute, attributes = {})
  singleton: 0
  id: 450
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 449
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 451
  comment: ""
new_record: true

--- !ruby/object:RaSourceCode 
attributes: 
  id: 452
  source_code: |-
    # File testdoc-1.0.0/base.rb, line 1761
          def clone_attribute_value(reader_method, attribute_name)
            value = send(reader_method, attribute_name)
            value.clone
          rescue TypeError, NoMethodError
            value
          end
new_record: true

--- !ruby/object:RaMethod 
attributes: 
  name: clone_attribute_value
  visibility: 2
  ra_comment_id: 451
  ra_container_id: 30
  parameters: (reader_method, attribute_name)
  singleton: 0
  id: 453
  block_parameters: 
  force_documentation: 0
  ra_source_code_id: 452
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: set_table_name
  ra_container_id: 30
  type: RaAlias
  id: 454
  value: table_name=
  comment: ""
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: set_primary_key
  ra_container_id: 30
  type: RaAlias
  id: 455
  value: primary_key=
  comment: ""
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: set_inheritance_column
  ra_container_id: 30
  type: RaAlias
  id: 456
  value: inheritance_column=
  comment: ""
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: set_sequence_name
  ra_container_id: 30
  type: RaAlias
  id: 457
  value: sequence_name=
  comment: ""
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: sanitize_sql
  ra_container_id: 30
  type: RaAlias
  id: 458
  value: sanitize_conditions
  comment: ""
new_record: true

--- !ruby/object:RaAlias 
attributes: 
  name: respond_to?
  ra_container_id: 30
  type: RaAlias
  id: 459
  value: respond_to_without_attributes?
  comment: |
    # For checking respond_to? without searching the attributes (which is faster).

new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 30
  file_name: testdoc-1.0.0/base.rb
  id: 460
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 461
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 461
  name: SerializationTypeMismatch
  ra_library_id: 0
  type: RaClass
  id: 462
  parent_id: 9
  full_name: ActiveRecord::SerializationTypeMismatch
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 462
  file_name: testdoc-1.0.0/base.rb
  id: 463
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 464
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: StandardError
  ra_comment_id: 464
  name: ActiveRecordError
  ra_library_id: 0
  type: RaClass
  id: 465
  parent_id: 9
  full_name: ActiveRecord::ActiveRecordError
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 465
  file_name: testdoc-1.0.0/base.rb
  id: 466
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 467
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: StandardError
  ra_comment_id: 467
  name: ConfigurationError
  ra_library_id: 0
  type: RaClass
  id: 468
  parent_id: 9
  full_name: ActiveRecord::ConfigurationError
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 468
  file_name: testdoc-1.0.0/base.rb
  id: 469
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 470
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 470
  name: ConnectionNotEstablished
  ra_library_id: 0
  type: RaClass
  id: 471
  parent_id: 9
  full_name: ActiveRecord::ConnectionNotEstablished
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 471
  file_name: testdoc-1.0.0/base.rb
  id: 472
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 473
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 473
  name: SubclassNotFound
  ra_library_id: 0
  type: RaClass
  id: 474
  parent_id: 9
  full_name: ActiveRecord::SubclassNotFound
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 474
  file_name: testdoc-1.0.0/base.rb
  id: 475
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 476
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 476
  name: MultiparameterAssignmentErrors
  ra_library_id: 0
  type: RaClass
  id: 477
  parent_id: 9
  full_name: ActiveRecord::MultiparameterAssignmentErrors
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 477
  file_name: testdoc-1.0.0/base.rb
  id: 478
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 479
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 479
  name: AdapterNotFound
  ra_library_id: 0
  type: RaClass
  id: 480
  parent_id: 9
  full_name: ActiveRecord::AdapterNotFound
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 480
  file_name: testdoc-1.0.0/base.rb
  id: 481
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 482
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 482
  name: StaleObjectError
  ra_library_id: 0
  type: RaClass
  id: 483
  parent_id: 9
  full_name: ActiveRecord::StaleObjectError
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 483
  file_name: testdoc-1.0.0/base.rb
  id: 484
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 485
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 485
  name: PreparedStatementInvalid
  ra_library_id: 0
  type: RaClass
  id: 486
  parent_id: 9
  full_name: ActiveRecord::PreparedStatementInvalid
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 486
  file_name: testdoc-1.0.0/base.rb
  id: 487
new_record: true

--- !ruby/object:RaComment 
attributes: 
  id: 488
  comment: ""
new_record: true

--- !ruby/object:RaClass 
attributes: 
  superclass: ActiveRecordError
  ra_comment_id: 488
  name: ConnectionFailed
  ra_library_id: 0
  type: RaClass
  id: 489
  parent_id: 9
  full_name: ActiveRecord::ConnectionFailed
new_record: true

--- !ruby/object:RaInFile 
attributes: 
  ra_container_id: 489
  file_name: testdoc-1.0.0/base.rb
  id: 490
new_record: true

